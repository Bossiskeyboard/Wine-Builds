From b73f479db67bad7a2f55dedf6ed6090dba9cfa4f Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 23 Jan 2026 14:27:01 +0100
Subject: [PATCH] winevulkan: Update to VK spec version 1.4.340.

---
 dlls/winevulkan/loader_thunks.c |  130 ++
 dlls/winevulkan/loader_thunks.h |   95 ++
 dlls/winevulkan/make_vulkan     |    7 +-
 dlls/winevulkan/vulkan_thunks.c | 2401 ++++++++++++++++++++++++++++---
 dlls/winevulkan/winevulkan.json |    2 +-
 include/wine/vulkan.h           |  540 ++++++-
 6 files changed, 2936 insertions(+), 239 deletions(-)

diff --git a/dlls/winevulkan/loader_thunks.c b/dlls/winevulkan/loader_thunks.c
index a09419d2663..a403d3b9ae8 100644
--- a/dlls/winevulkan/loader_thunks.c
+++ b/dlls/winevulkan/loader_thunks.c
@@ -511,6 +511,22 @@ void WINAPI vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipe
     UNIX_CALL(vkCmdBindPipelineShaderGroupNV, &params);
 }
 
+void WINAPI vkCmdBindResourceHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo)
+{
+    struct vkCmdBindResourceHeapEXT_params params;
+    params.commandBuffer = commandBuffer;
+    params.pBindInfo = pBindInfo;
+    UNIX_CALL(vkCmdBindResourceHeapEXT, &params);
+}
+
+void WINAPI vkCmdBindSamplerHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo)
+{
+    struct vkCmdBindSamplerHeapEXT_params params;
+    params.commandBuffer = commandBuffer;
+    params.pBindInfo = pBindInfo;
+    UNIX_CALL(vkCmdBindSamplerHeapEXT, &params);
+}
+
 void WINAPI vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders)
 {
     struct vkCmdBindShadersEXT_params params;
@@ -1628,6 +1644,14 @@ void WINAPI vkCmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushCo
     UNIX_CALL(vkCmdPushConstants2KHR, &params);
 }
 
+void WINAPI vkCmdPushDataEXT(VkCommandBuffer commandBuffer, const VkPushDataInfoEXT *pPushDataInfo)
+{
+    struct vkCmdPushDataEXT_params params;
+    params.commandBuffer = commandBuffer;
+    params.pPushDataInfo = pPushDataInfo;
+    UNIX_CALL(vkCmdPushDataEXT, &params);
+}
+
 void WINAPI vkCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites)
 {
     struct vkCmdPushDescriptorSet_params params;
@@ -4793,6 +4817,18 @@ void WINAPI vkGetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDevi
     assert(!status && "vkGetDeviceBufferMemoryRequirementsKHR");
 }
 
+uint64_t WINAPI vkGetDeviceCombinedImageSamplerIndexNVX(VkDevice device, uint64_t imageViewIndex, uint64_t samplerIndex)
+{
+    struct vkGetDeviceCombinedImageSamplerIndexNVX_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.imageViewIndex = imageViewIndex;
+    params.samplerIndex = samplerIndex;
+    status = UNIX_CALL(vkGetDeviceCombinedImageSamplerIndexNVX, &params);
+    assert(!status && "vkGetDeviceCombinedImageSamplerIndexNVX");
+    return params.result;
+}
+
 VkResult WINAPI vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo)
 {
     struct vkGetDeviceFaultInfoEXT_params params;
@@ -5140,6 +5176,19 @@ void WINAPI vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemor
     assert(!status && "vkGetImageMemoryRequirements2KHR");
 }
 
+VkResult WINAPI vkGetImageOpaqueCaptureDataEXT(VkDevice device, uint32_t imageCount, const VkImage *pImages, VkHostAddressRangeEXT *pDatas)
+{
+    struct vkGetImageOpaqueCaptureDataEXT_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.imageCount = imageCount;
+    params.pImages = pImages;
+    params.pDatas = pDatas;
+    status = UNIX_CALL(vkGetImageOpaqueCaptureDataEXT, &params);
+    assert(!status && "vkGetImageOpaqueCaptureDataEXT");
+    return params.result;
+}
+
 VkResult WINAPI vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData)
 {
     struct vkGetImageOpaqueCaptureDescriptorDataEXT_params params;
@@ -5438,6 +5487,17 @@ VkResult WINAPI vkGetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevic
     return params.result;
 }
 
+VkDeviceSize WINAPI vkGetPhysicalDeviceDescriptorSizeEXT(VkPhysicalDevice physicalDevice, VkDescriptorType descriptorType)
+{
+    struct vkGetPhysicalDeviceDescriptorSizeEXT_params params;
+    NTSTATUS status;
+    params.physicalDevice = physicalDevice;
+    params.descriptorType = descriptorType;
+    status = UNIX_CALL(vkGetPhysicalDeviceDescriptorSizeEXT, &params);
+    assert(!status && "vkGetPhysicalDeviceDescriptorSizeEXT");
+    return params.result;
+}
+
 void WINAPI vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
 {
     struct vkGetPhysicalDeviceExternalBufferProperties_params params;
@@ -6385,6 +6445,19 @@ void WINAPI vkGetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemo
     assert(!status && "vkGetTensorMemoryRequirementsARM");
 }
 
+VkResult WINAPI vkGetTensorOpaqueCaptureDataARM(VkDevice device, uint32_t tensorCount, const VkTensorARM *pTensors, VkHostAddressRangeEXT *pDatas)
+{
+    struct vkGetTensorOpaqueCaptureDataARM_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.tensorCount = tensorCount;
+    params.pTensors = pTensors;
+    params.pDatas = pDatas;
+    status = UNIX_CALL(vkGetTensorOpaqueCaptureDataARM, &params);
+    assert(!status && "vkGetTensorOpaqueCaptureDataARM");
+    return params.result;
+}
+
 VkResult WINAPI vkGetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData)
 {
     struct vkGetTensorOpaqueCaptureDescriptorDataARM_params params;
@@ -6680,6 +6753,19 @@ VkResult WINAPI vkQueueWaitIdle(VkQueue queue)
     return params.result;
 }
 
+VkResult WINAPI vkRegisterCustomBorderColorEXT(VkDevice device, const VkSamplerCustomBorderColorCreateInfoEXT *pBorderColor, VkBool32 requestIndex, uint32_t *pIndex)
+{
+    struct vkRegisterCustomBorderColorEXT_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.pBorderColor = pBorderColor;
+    params.requestIndex = requestIndex;
+    params.pIndex = pIndex;
+    status = UNIX_CALL(vkRegisterCustomBorderColorEXT, &params);
+    assert(!status && "vkRegisterCustomBorderColorEXT");
+    return params.result;
+}
+
 VkResult WINAPI vkReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator)
 {
     struct vkReleaseCapturedPipelineDataKHR_params params;
@@ -7044,6 +7130,16 @@ VkResult WINAPI vkUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMem
     return params.result;
 }
 
+void WINAPI vkUnregisterCustomBorderColorEXT(VkDevice device, uint32_t index)
+{
+    struct vkUnregisterCustomBorderColorEXT_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.index = index;
+    status = UNIX_CALL(vkUnregisterCustomBorderColorEXT, &params);
+    assert(!status && "vkUnregisterCustomBorderColorEXT");
+}
+
 void WINAPI vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
 {
     struct vkUpdateDescriptorSetWithTemplate_params params;
@@ -7208,6 +7304,28 @@ VkResult WINAPI vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromap
     return params.result;
 }
 
+VkResult WINAPI vkWriteResourceDescriptorsEXT(VkDevice device, uint32_t resourceCount, const VkResourceDescriptorInfoEXT *pResources, const VkHostAddressRangeEXT *pDescriptors)
+{
+    struct vkWriteResourceDescriptorsEXT_params params;
+    params.device = device;
+    params.resourceCount = resourceCount;
+    params.pResources = pResources;
+    params.pDescriptors = pDescriptors;
+    UNIX_CALL(vkWriteResourceDescriptorsEXT, &params);
+    return params.result;
+}
+
+VkResult WINAPI vkWriteSamplerDescriptorsEXT(VkDevice device, uint32_t samplerCount, const VkSamplerCreateInfo *pSamplers, const VkHostAddressRangeEXT *pDescriptors)
+{
+    struct vkWriteSamplerDescriptorsEXT_params params;
+    params.device = device;
+    params.samplerCount = samplerCount;
+    params.pSamplers = pSamplers;
+    params.pDescriptors = pDescriptors;
+    UNIX_CALL(vkWriteSamplerDescriptorsEXT, &params);
+    return params.result;
+}
+
 static const struct vulkan_func vk_device_dispatch_table[] =
 {
     {"vkAcquireNextImage2KHR", vkAcquireNextImage2KHR},
@@ -7257,6 +7375,8 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkCmdBindInvocationMaskHUAWEI", vkCmdBindInvocationMaskHUAWEI},
     {"vkCmdBindPipeline", vkCmdBindPipeline},
     {"vkCmdBindPipelineShaderGroupNV", vkCmdBindPipelineShaderGroupNV},
+    {"vkCmdBindResourceHeapEXT", vkCmdBindResourceHeapEXT},
+    {"vkCmdBindSamplerHeapEXT", vkCmdBindSamplerHeapEXT},
     {"vkCmdBindShadersEXT", vkCmdBindShadersEXT},
     {"vkCmdBindShadingRateImageNV", vkCmdBindShadingRateImageNV},
     {"vkCmdBindTileMemoryQCOM", vkCmdBindTileMemoryQCOM},
@@ -7371,6 +7491,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkCmdPushConstants", vkCmdPushConstants},
     {"vkCmdPushConstants2", vkCmdPushConstants2},
     {"vkCmdPushConstants2KHR", vkCmdPushConstants2KHR},
+    {"vkCmdPushDataEXT", vkCmdPushDataEXT},
     {"vkCmdPushDescriptorSet", vkCmdPushDescriptorSet},
     {"vkCmdPushDescriptorSet2", vkCmdPushDescriptorSet2},
     {"vkCmdPushDescriptorSet2KHR", vkCmdPushDescriptorSet2KHR},
@@ -7659,6 +7780,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetDeviceAccelerationStructureCompatibilityKHR", vkGetDeviceAccelerationStructureCompatibilityKHR},
     {"vkGetDeviceBufferMemoryRequirements", vkGetDeviceBufferMemoryRequirements},
     {"vkGetDeviceBufferMemoryRequirementsKHR", vkGetDeviceBufferMemoryRequirementsKHR},
+    {"vkGetDeviceCombinedImageSamplerIndexNVX", vkGetDeviceCombinedImageSamplerIndexNVX},
     {"vkGetDeviceFaultInfoEXT", vkGetDeviceFaultInfoEXT},
     {"vkGetDeviceGroupPeerMemoryFeatures", vkGetDeviceGroupPeerMemoryFeatures},
     {"vkGetDeviceGroupPeerMemoryFeaturesKHR", vkGetDeviceGroupPeerMemoryFeaturesKHR},
@@ -7690,6 +7812,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetImageMemoryRequirements", vkGetImageMemoryRequirements},
     {"vkGetImageMemoryRequirements2", vkGetImageMemoryRequirements2},
     {"vkGetImageMemoryRequirements2KHR", vkGetImageMemoryRequirements2KHR},
+    {"vkGetImageOpaqueCaptureDataEXT", vkGetImageOpaqueCaptureDataEXT},
     {"vkGetImageOpaqueCaptureDescriptorDataEXT", vkGetImageOpaqueCaptureDescriptorDataEXT},
     {"vkGetImageSparseMemoryRequirements", vkGetImageSparseMemoryRequirements},
     {"vkGetImageSparseMemoryRequirements2", vkGetImageSparseMemoryRequirements2},
@@ -7740,6 +7863,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetShaderModuleIdentifierEXT", vkGetShaderModuleIdentifierEXT},
     {"vkGetSwapchainImagesKHR", vkGetSwapchainImagesKHR},
     {"vkGetTensorMemoryRequirementsARM", vkGetTensorMemoryRequirementsARM},
+    {"vkGetTensorOpaqueCaptureDataARM", vkGetTensorOpaqueCaptureDataARM},
     {"vkGetTensorOpaqueCaptureDescriptorDataARM", vkGetTensorOpaqueCaptureDescriptorDataARM},
     {"vkGetTensorViewOpaqueCaptureDescriptorDataARM", vkGetTensorViewOpaqueCaptureDescriptorDataARM},
     {"vkGetValidationCacheDataEXT", vkGetValidationCacheDataEXT},
@@ -7765,6 +7889,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkQueueSubmit2", vkQueueSubmit2},
     {"vkQueueSubmit2KHR", vkQueueSubmit2KHR},
     {"vkQueueWaitIdle", vkQueueWaitIdle},
+    {"vkRegisterCustomBorderColorEXT", vkRegisterCustomBorderColorEXT},
     {"vkReleaseCapturedPipelineDataKHR", vkReleaseCapturedPipelineDataKHR},
     {"vkReleasePerformanceConfigurationINTEL", vkReleasePerformanceConfigurationINTEL},
     {"vkReleaseProfilingLockKHR", vkReleaseProfilingLockKHR},
@@ -7796,6 +7921,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkUnmapMemory", vkUnmapMemory},
     {"vkUnmapMemory2", vkUnmapMemory2},
     {"vkUnmapMemory2KHR", vkUnmapMemory2KHR},
+    {"vkUnregisterCustomBorderColorEXT", vkUnregisterCustomBorderColorEXT},
     {"vkUpdateDescriptorSetWithTemplate", vkUpdateDescriptorSetWithTemplate},
     {"vkUpdateDescriptorSetWithTemplateKHR", vkUpdateDescriptorSetWithTemplateKHR},
     {"vkUpdateDescriptorSets", vkUpdateDescriptorSets},
@@ -7809,6 +7935,8 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkWaitSemaphoresKHR", vkWaitSemaphoresKHR},
     {"vkWriteAccelerationStructuresPropertiesKHR", vkWriteAccelerationStructuresPropertiesKHR},
     {"vkWriteMicromapsPropertiesEXT", vkWriteMicromapsPropertiesEXT},
+    {"vkWriteResourceDescriptorsEXT", vkWriteResourceDescriptorsEXT},
+    {"vkWriteSamplerDescriptorsEXT", vkWriteSamplerDescriptorsEXT},
 };
 
 static const struct vulkan_func vk_phys_dev_dispatch_table[] =
@@ -7824,6 +7952,7 @@ static const struct vulkan_func vk_phys_dev_dispatch_table[] =
     {"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR},
     {"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", vkGetPhysicalDeviceCooperativeMatrixPropertiesNV},
     {"vkGetPhysicalDeviceCooperativeVectorPropertiesNV", vkGetPhysicalDeviceCooperativeVectorPropertiesNV},
+    {"vkGetPhysicalDeviceDescriptorSizeEXT", vkGetPhysicalDeviceDescriptorSizeEXT},
     {"vkGetPhysicalDeviceExternalBufferProperties", vkGetPhysicalDeviceExternalBufferProperties},
     {"vkGetPhysicalDeviceExternalBufferPropertiesKHR", vkGetPhysicalDeviceExternalBufferPropertiesKHR},
     {"vkGetPhysicalDeviceExternalFenceProperties", vkGetPhysicalDeviceExternalFenceProperties},
@@ -7898,6 +8027,7 @@ static const struct vulkan_func vk_instance_dispatch_table[] =
     {"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR},
     {"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", vkGetPhysicalDeviceCooperativeMatrixPropertiesNV},
     {"vkGetPhysicalDeviceCooperativeVectorPropertiesNV", vkGetPhysicalDeviceCooperativeVectorPropertiesNV},
+    {"vkGetPhysicalDeviceDescriptorSizeEXT", vkGetPhysicalDeviceDescriptorSizeEXT},
     {"vkGetPhysicalDeviceExternalBufferProperties", vkGetPhysicalDeviceExternalBufferProperties},
     {"vkGetPhysicalDeviceExternalBufferPropertiesKHR", vkGetPhysicalDeviceExternalBufferPropertiesKHR},
     {"vkGetPhysicalDeviceExternalFenceProperties", vkGetPhysicalDeviceExternalFenceProperties},
diff --git a/dlls/winevulkan/loader_thunks.h b/dlls/winevulkan/loader_thunks.h
index a886dfa6430..b80445ed55e 100644
--- a/dlls/winevulkan/loader_thunks.h
+++ b/dlls/winevulkan/loader_thunks.h
@@ -70,6 +70,8 @@ enum unix_call
     unix_vkCmdBindInvocationMaskHUAWEI,
     unix_vkCmdBindPipeline,
     unix_vkCmdBindPipelineShaderGroupNV,
+    unix_vkCmdBindResourceHeapEXT,
+    unix_vkCmdBindSamplerHeapEXT,
     unix_vkCmdBindShadersEXT,
     unix_vkCmdBindShadingRateImageNV,
     unix_vkCmdBindTileMemoryQCOM,
@@ -184,6 +186,7 @@ enum unix_call
     unix_vkCmdPushConstants,
     unix_vkCmdPushConstants2,
     unix_vkCmdPushConstants2KHR,
+    unix_vkCmdPushDataEXT,
     unix_vkCmdPushDescriptorSet,
     unix_vkCmdPushDescriptorSet2,
     unix_vkCmdPushDescriptorSet2KHR,
@@ -491,6 +494,7 @@ enum unix_call
     unix_vkGetDeviceAccelerationStructureCompatibilityKHR,
     unix_vkGetDeviceBufferMemoryRequirements,
     unix_vkGetDeviceBufferMemoryRequirementsKHR,
+    unix_vkGetDeviceCombinedImageSamplerIndexNVX,
     unix_vkGetDeviceFaultInfoEXT,
     unix_vkGetDeviceGroupPeerMemoryFeatures,
     unix_vkGetDeviceGroupPeerMemoryFeaturesKHR,
@@ -521,6 +525,7 @@ enum unix_call
     unix_vkGetImageMemoryRequirements,
     unix_vkGetImageMemoryRequirements2,
     unix_vkGetImageMemoryRequirements2KHR,
+    unix_vkGetImageOpaqueCaptureDataEXT,
     unix_vkGetImageOpaqueCaptureDescriptorDataEXT,
     unix_vkGetImageSparseMemoryRequirements,
     unix_vkGetImageSparseMemoryRequirements2,
@@ -546,6 +551,7 @@ enum unix_call
     unix_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
     unix_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
     unix_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
+    unix_vkGetPhysicalDeviceDescriptorSizeEXT,
     unix_vkGetPhysicalDeviceExternalBufferProperties,
     unix_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
     unix_vkGetPhysicalDeviceExternalFenceProperties,
@@ -625,6 +631,7 @@ enum unix_call
     unix_vkGetShaderModuleIdentifierEXT,
     unix_vkGetSwapchainImagesKHR,
     unix_vkGetTensorMemoryRequirementsARM,
+    unix_vkGetTensorOpaqueCaptureDataARM,
     unix_vkGetTensorOpaqueCaptureDescriptorDataARM,
     unix_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     unix_vkGetValidationCacheDataEXT,
@@ -650,6 +657,7 @@ enum unix_call
     unix_vkQueueSubmit2,
     unix_vkQueueSubmit2KHR,
     unix_vkQueueWaitIdle,
+    unix_vkRegisterCustomBorderColorEXT,
     unix_vkReleaseCapturedPipelineDataKHR,
     unix_vkReleasePerformanceConfigurationINTEL,
     unix_vkReleaseProfilingLockKHR,
@@ -682,6 +690,7 @@ enum unix_call
     unix_vkUnmapMemory,
     unix_vkUnmapMemory2,
     unix_vkUnmapMemory2KHR,
+    unix_vkUnregisterCustomBorderColorEXT,
     unix_vkUpdateDescriptorSetWithTemplate,
     unix_vkUpdateDescriptorSetWithTemplateKHR,
     unix_vkUpdateDescriptorSets,
@@ -695,6 +704,8 @@ enum unix_call
     unix_vkWaitSemaphoresKHR,
     unix_vkWriteAccelerationStructuresPropertiesKHR,
     unix_vkWriteMicromapsPropertiesEXT,
+    unix_vkWriteResourceDescriptorsEXT,
+    unix_vkWriteSamplerDescriptorsEXT,
     unix_count,
 };
 
@@ -1064,6 +1075,18 @@ struct vkCmdBindPipelineShaderGroupNV_params
     uint32_t groupIndex;
 };
 
+struct vkCmdBindResourceHeapEXT_params
+{
+    VkCommandBuffer commandBuffer;
+    const VkBindHeapInfoEXT *pBindInfo;
+};
+
+struct vkCmdBindSamplerHeapEXT_params
+{
+    VkCommandBuffer commandBuffer;
+    const VkBindHeapInfoEXT *pBindInfo;
+};
+
 struct vkCmdBindShadersEXT_params
 {
     VkCommandBuffer commandBuffer;
@@ -1953,6 +1976,12 @@ struct vkCmdPushConstants2KHR_params
     const VkPushConstantsInfo *pPushConstantsInfo;
 };
 
+struct vkCmdPushDataEXT_params
+{
+    VkCommandBuffer commandBuffer;
+    const VkPushDataInfoEXT *pPushDataInfo;
+};
+
 struct vkCmdPushDescriptorSet_params
 {
     VkCommandBuffer commandBuffer;
@@ -4280,6 +4309,14 @@ struct vkGetDeviceBufferMemoryRequirementsKHR_params
     VkMemoryRequirements2 *pMemoryRequirements;
 };
 
+struct vkGetDeviceCombinedImageSamplerIndexNVX_params
+{
+    VkDevice device;
+    uint64_t DECLSPEC_ALIGN(8) imageViewIndex;
+    uint64_t DECLSPEC_ALIGN(8) samplerIndex;
+    uint64_t result;
+};
+
 struct vkGetDeviceFaultInfoEXT_params
 {
     VkDevice device;
@@ -4507,6 +4544,15 @@ struct vkGetImageMemoryRequirements2KHR_params
     VkMemoryRequirements2 *pMemoryRequirements;
 };
 
+struct vkGetImageOpaqueCaptureDataEXT_params
+{
+    VkDevice device;
+    uint32_t imageCount;
+    const VkImage *pImages;
+    VkHostAddressRangeEXT *pDatas;
+    VkResult result;
+};
+
 struct vkGetImageOpaqueCaptureDescriptorDataEXT_params
 {
     VkDevice device;
@@ -4705,6 +4751,13 @@ struct vkGetPhysicalDeviceCooperativeVectorPropertiesNV_params
     VkResult result;
 };
 
+struct vkGetPhysicalDeviceDescriptorSizeEXT_params
+{
+    VkPhysicalDevice physicalDevice;
+    VkDescriptorType descriptorType;
+    VkDeviceSize result;
+};
+
 struct vkGetPhysicalDeviceExternalBufferProperties_params
 {
     VkPhysicalDevice physicalDevice;
@@ -5336,6 +5389,15 @@ struct vkGetTensorMemoryRequirementsARM_params
     VkMemoryRequirements2 *pMemoryRequirements;
 };
 
+struct vkGetTensorOpaqueCaptureDataARM_params
+{
+    VkDevice device;
+    uint32_t tensorCount;
+    const VkTensorARM *pTensors;
+    VkHostAddressRangeEXT *pDatas;
+    VkResult result;
+};
+
 struct vkGetTensorOpaqueCaptureDescriptorDataARM_params
 {
     VkDevice device;
@@ -5531,6 +5593,15 @@ struct vkQueueWaitIdle_params
     VkResult result;
 };
 
+struct vkRegisterCustomBorderColorEXT_params
+{
+    VkDevice device;
+    const VkSamplerCustomBorderColorCreateInfoEXT *pBorderColor;
+    VkBool32 requestIndex;
+    uint32_t *pIndex;
+    VkResult result;
+};
+
 struct vkReleaseCapturedPipelineDataKHR_params
 {
     VkDevice device;
@@ -5767,6 +5838,12 @@ struct vkUnmapMemory2KHR_params
     VkResult result;
 };
 
+struct vkUnregisterCustomBorderColorEXT_params
+{
+    VkDevice device;
+    uint32_t index;
+};
+
 struct vkUpdateDescriptorSetWithTemplate_params
 {
     VkDevice device;
@@ -5883,4 +5960,22 @@ struct vkWriteMicromapsPropertiesEXT_params
     VkResult result;
 };
 
+struct vkWriteResourceDescriptorsEXT_params
+{
+    VkDevice device;
+    uint32_t resourceCount;
+    const VkResourceDescriptorInfoEXT *pResources;
+    const VkHostAddressRangeEXT *pDescriptors;
+    VkResult result;
+};
+
+struct vkWriteSamplerDescriptorsEXT_params
+{
+    VkDevice device;
+    uint32_t samplerCount;
+    const VkSamplerCreateInfo *pSamplers;
+    const VkHostAddressRangeEXT *pDescriptors;
+    VkResult result;
+};
+
 #endif /* __WINE_VULKAN_LOADER_THUNKS_H */
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index fa8d43e10e6..8a4b88e3694 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -64,7 +64,7 @@ from enum import Enum
 LOGGER = logging.Logger("vulkan")
 LOGGER.addHandler(logging.StreamHandler())
 
-VK_XML_VERSION = "1.4.339"
+VK_XML_VERSION = "1.4.340"
 
 # Filenames to create.
 WINE_VULKAN_H = "../../include/wine/vulkan.h"
@@ -171,6 +171,8 @@ PERF_CRITICAL_FUNCTIONS = [
     "vkUpdateDescriptorSets",
     "vkUpdateDescriptorSetWithTemplate",
     "vkGetDescriptorEXT",
+    "vkWriteResourceDescriptorsEXT",
+    "vkWriteSamplerDescriptorsEXT",
 ]
 
 # Table of functions for which we have a special implementation.
@@ -2149,6 +2151,9 @@ class StructConversionFunction(object):
 
             params = ["const {0} *in".format(self.type), "{0} *out".format(self.type)]
 
+            if self.operand.union:
+                params.append("VkFlags selector")
+
             # Generate parameter list
             if needs_alloc:
                 body += "struct conversion_context *ctx, "
diff --git a/dlls/winevulkan/vulkan_thunks.c b/dlls/winevulkan/vulkan_thunks.c
index f12789ac380..d6370c8c8af 100644
--- a/dlls/winevulkan/vulkan_thunks.c
+++ b/dlls/winevulkan/vulkan_thunks.c
@@ -54,6 +54,28 @@ typedef struct VkGeometryTrianglesNV32
     VkDeviceSize DECLSPEC_ALIGN(8) transformOffset;
 } VkGeometryTrianglesNV32;
 
+typedef struct VkSamplerCreateInfo32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkSamplerCreateFlags flags;
+    VkFilter magFilter;
+    VkFilter minFilter;
+    VkSamplerMipmapMode mipmapMode;
+    VkSamplerAddressMode addressModeU;
+    VkSamplerAddressMode addressModeV;
+    VkSamplerAddressMode addressModeW;
+    float mipLodBias;
+    VkBool32 anisotropyEnable;
+    float maxAnisotropy;
+    VkBool32 compareEnable;
+    VkCompareOp compareOp;
+    float minLod;
+    float maxLod;
+    VkBorderColor borderColor;
+    VkBool32 unnormalizedCoordinates;
+} VkSamplerCreateInfo32;
+
 typedef struct VkSpecializationMapEntry32
 {
     uint32_t constantID;
@@ -141,12 +163,97 @@ typedef struct VkClusterAccelerationStructureTriangleClusterInputNV32
     uint32_t minPositionTruncateBitCount;
 } VkClusterAccelerationStructureTriangleClusterInputNV32;
 
+typedef struct VkDescriptorMappingSourceConstantOffsetEXT32
+{
+    uint32_t heapOffset;
+    uint32_t heapArrayStride;
+    PTR32 pEmbeddedSampler;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceConstantOffsetEXT32;
+
+typedef struct VkDescriptorMappingSourceIndirectIndexArrayEXT32
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t addressOffset;
+    uint32_t heapIndexStride;
+    PTR32 pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerAddressOffset;
+    uint32_t samplerHeapIndexStride;
+} VkDescriptorMappingSourceIndirectIndexArrayEXT32;
+
+typedef struct VkDescriptorMappingSourceIndirectIndexEXT32
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t addressOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    PTR32 pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerAddressOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceIndirectIndexEXT32;
+
+typedef struct VkDescriptorMappingSourcePushIndexEXT32
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    PTR32 pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourcePushIndexEXT32;
+
+typedef struct VkDescriptorMappingSourceShaderRecordIndexEXT32
+{
+    uint32_t heapOffset;
+    uint32_t shaderRecordOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    PTR32 pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerShaderRecordOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceShaderRecordIndexEXT32;
+
+typedef struct VkDeviceAddressRangeEXT32
+{
+    VkDeviceAddress DECLSPEC_ALIGN(8) address;
+    VkDeviceSize DECLSPEC_ALIGN(8) size;
+} VkDeviceAddressRangeEXT32;
+
 typedef struct VkGeometryDataNV32
 {
     VkGeometryTrianglesNV32 DECLSPEC_ALIGN(8) triangles;
     VkGeometryAABBNV32 DECLSPEC_ALIGN(8) aabbs;
 } VkGeometryDataNV32;
 
+typedef struct VkImageViewCreateInfo32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkImageViewCreateFlags flags;
+    VkImage DECLSPEC_ALIGN(8) image;
+    VkImageViewType viewType;
+    VkFormat format;
+    VkComponentMapping components;
+    VkImageSubresourceRange subresourceRange;
+} VkImageViewCreateInfo32;
+
 typedef struct VkIndirectExecutionSetShaderLayoutInfoEXT32
 {
     VkStructureType sType;
@@ -408,6 +515,21 @@ typedef struct VkDescriptorImageInfo32
     VkImageLayout imageLayout;
 } VkDescriptorImageInfo32;
 
+typedef union VkDescriptorMappingSourceDataEXT32
+{
+    VkDescriptorMappingSourceConstantOffsetEXT32 constantOffset;
+    VkDescriptorMappingSourcePushIndexEXT32 pushIndex;
+    VkDescriptorMappingSourceIndirectIndexEXT32 indirectIndex;
+    VkDescriptorMappingSourceIndirectIndexArrayEXT32 indirectIndexArray;
+    VkDescriptorMappingSourceHeapDataEXT heapData;
+    uint32_t pushDataOffset;
+    uint32_t pushAddressOffset;
+    VkDescriptorMappingSourceIndirectAddressEXT indirectAddress;
+    VkDescriptorMappingSourceShaderRecordIndexEXT32 shaderRecordIndex;
+    uint32_t shaderRecordDataOffset;
+    uint32_t shaderRecordAddressOffset;
+} VkDescriptorMappingSourceDataEXT32;
+
 typedef struct VkGeometryNV32
 {
     VkStructureType sType;
@@ -436,6 +558,14 @@ typedef struct VkImageCreateInfo32
     VkImageLayout initialLayout;
 } VkImageCreateInfo32;
 
+typedef struct VkImageDescriptorInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    PTR32 pView;
+    VkImageLayout layout;
+} VkImageDescriptorInfoEXT32;
+
 typedef union VkIndirectCommandsTokenDataEXT32
 {
     PTR32 pPushConstant;
@@ -568,6 +698,23 @@ typedef struct VkTensorDescriptionARM32
     VkTensorUsageFlagsARM DECLSPEC_ALIGN(8) usage;
 } VkTensorDescriptionARM32;
 
+typedef struct VkTensorViewCreateInfoARM32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkTensorViewCreateFlagsARM DECLSPEC_ALIGN(8) flags;
+    VkTensorARM DECLSPEC_ALIGN(8) tensor;
+    VkFormat format;
+} VkTensorViewCreateInfoARM32;
+
+typedef struct VkTexelBufferDescriptorInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkFormat format;
+    VkDeviceAddressRangeEXT32 DECLSPEC_ALIGN(8) addressRange;
+} VkTexelBufferDescriptorInfoEXT32;
+
 typedef struct VkVideoPictureResourceInfoKHR32
 {
     VkStructureType sType;
@@ -769,6 +916,15 @@ typedef struct VkAttachmentSampleLocationsEXT32
     VkSampleLocationsInfoEXT32 sampleLocationsInfo;
 } VkAttachmentSampleLocationsEXT32;
 
+typedef struct VkBindHeapInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkDeviceAddressRangeEXT32 DECLSPEC_ALIGN(8) heapRange;
+    VkDeviceSize DECLSPEC_ALIGN(8) reservedRangeOffset;
+    VkDeviceSize DECLSPEC_ALIGN(8) reservedRangeSize;
+} VkBindHeapInfoEXT32;
+
 typedef struct VkBufferCopy232
 {
     VkStructureType sType;
@@ -916,6 +1072,18 @@ typedef union VkDescriptorDataEXT32
     VkDeviceAddress DECLSPEC_ALIGN(8) accelerationStructure;
 } VkDescriptorDataEXT32;
 
+typedef struct VkDescriptorSetAndBindingMappingEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t descriptorSet;
+    uint32_t firstBinding;
+    uint32_t bindingCount;
+    VkSpirvResourceTypeFlagsEXT resourceMask;
+    VkDescriptorMappingSourceEXT source;
+    VkDescriptorMappingSourceDataEXT32 sourceData;
+} VkDescriptorSetAndBindingMappingEXT32;
+
 typedef struct VkDescriptorSetLayoutBinding32
 {
     uint32_t binding;
@@ -984,6 +1152,12 @@ typedef struct VkGraphicsShaderGroupCreateInfoNV32
     PTR32 pTessellationState;
 } VkGraphicsShaderGroupCreateInfoNV32;
 
+typedef struct VkHostAddressRangeConstEXT32
+{
+    PTR32 address;
+    PTR32 size;
+} VkHostAddressRangeConstEXT32;
+
 typedef struct VkImageBlit232
 {
     VkStructureType sType;
@@ -1411,6 +1585,14 @@ typedef struct VkRenderingAttachmentInfo32
 } VkRenderingAttachmentInfo32;
 typedef VkRenderingAttachmentInfo32 VkRenderingAttachmentInfoKHR32;
 
+typedef union VkResourceDescriptorDataEXT32
+{
+    PTR32 pImage;
+    PTR32 pTexelBuffer;
+    PTR32 pAddressRange;
+    PTR32 pTensorARM;
+} VkResourceDescriptorDataEXT32;
+
 typedef struct VkSemaphoreSubmitInfo32
 {
     VkStructureType sType;
@@ -2168,6 +2350,14 @@ typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT32
     VkBool32 conditionalRenderingEnable;
 } VkCommandBufferInheritanceConditionalRenderingInfoEXT32;
 
+typedef struct VkCommandBufferInheritanceDescriptorHeapInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    PTR32 pSamplerHeapBindInfo;
+    PTR32 pResourceHeapBindInfo;
+} VkCommandBufferInheritanceDescriptorHeapInfoEXT32;
+
 typedef struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM32
 {
     VkStructureType sType;
@@ -3559,6 +3749,12 @@ typedef struct VkHdrVividDynamicMetadataHUAWEI32
     PTR32 pDynamicMetadata;
 } VkHdrVividDynamicMetadataHUAWEI32;
 
+typedef struct VkHostAddressRangeEXT32
+{
+    PTR32 address;
+    PTR32 size;
+} VkHostAddressRangeEXT32;
+
 typedef struct VkHostImageCopyDevicePerformanceQuery32
 {
     VkStructureType sType;
@@ -3702,18 +3898,6 @@ typedef struct VkImageViewCaptureDescriptorDataInfoEXT32
     VkImageView DECLSPEC_ALIGN(8) imageView;
 } VkImageViewCaptureDescriptorDataInfoEXT32;
 
-typedef struct VkImageViewCreateInfo32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkImageViewCreateFlags flags;
-    VkImage DECLSPEC_ALIGN(8) image;
-    VkImageViewType viewType;
-    VkFormat format;
-    VkComponentMapping components;
-    VkImageSubresourceRange subresourceRange;
-} VkImageViewCreateInfo32;
-
 typedef struct VkImageViewHandleInfoNVX32
 {
     VkStructureType sType;
@@ -3818,6 +4002,14 @@ typedef struct VkIndirectCommandsLayoutCreateInfoNV32
     PTR32 pStreamStrides;
 } VkIndirectCommandsLayoutCreateInfoNV32;
 
+typedef struct VkIndirectCommandsLayoutPushDataTokenNV32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t pushDataOffset;
+    uint32_t pushDataSize;
+} VkIndirectCommandsLayoutPushDataTokenNV32;
+
 typedef struct VkIndirectExecutionSetCreateInfoEXT32
 {
     VkStructureType sType;
@@ -4095,6 +4287,13 @@ typedef struct VkMutableDescriptorTypeCreateInfoEXT32
 } VkMutableDescriptorTypeCreateInfoEXT32;
 typedef VkMutableDescriptorTypeCreateInfoEXT32 VkMutableDescriptorTypeCreateInfoVALVE32;
 
+typedef struct VkOpaqueCaptureDataCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    PTR32 pData;
+} VkOpaqueCaptureDataCreateInfoEXT32;
+
 typedef struct VkOpaqueCaptureDescriptorDataCreateInfoEXT32
 {
     VkStructureType sType;
@@ -4792,6 +4991,48 @@ typedef struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32
     PTR32 tensorDescriptorSize;
 } VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32;
 
+typedef struct VkPhysicalDeviceDescriptorHeapFeaturesEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 descriptorHeap;
+    VkBool32 descriptorHeapCaptureReplay;
+} VkPhysicalDeviceDescriptorHeapFeaturesEXT32;
+
+typedef struct VkPhysicalDeviceDescriptorHeapPropertiesEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkDeviceSize DECLSPEC_ALIGN(8) samplerHeapAlignment;
+    VkDeviceSize DECLSPEC_ALIGN(8) resourceHeapAlignment;
+    VkDeviceSize DECLSPEC_ALIGN(8) maxSamplerHeapSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) maxResourceHeapSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) minSamplerHeapReservedRange;
+    VkDeviceSize DECLSPEC_ALIGN(8) minSamplerHeapReservedRangeWithEmbedded;
+    VkDeviceSize DECLSPEC_ALIGN(8) minResourceHeapReservedRange;
+    VkDeviceSize DECLSPEC_ALIGN(8) samplerDescriptorSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) imageDescriptorSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) bufferDescriptorSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) samplerDescriptorAlignment;
+    VkDeviceSize DECLSPEC_ALIGN(8) imageDescriptorAlignment;
+    VkDeviceSize DECLSPEC_ALIGN(8) bufferDescriptorAlignment;
+    VkDeviceSize DECLSPEC_ALIGN(8) maxPushDataSize;
+    PTR32 imageCaptureReplayOpaqueDataSize;
+    uint32_t maxDescriptorHeapEmbeddedSamplers;
+    uint32_t samplerYcbcrConversionCount;
+    VkBool32 sparseDescriptorHeaps;
+    VkBool32 protectedDescriptorHeaps;
+} VkPhysicalDeviceDescriptorHeapPropertiesEXT32;
+
+typedef struct VkPhysicalDeviceDescriptorHeapTensorPropertiesARM32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkDeviceSize DECLSPEC_ALIGN(8) tensorDescriptorSize;
+    VkDeviceSize DECLSPEC_ALIGN(8) tensorDescriptorAlignment;
+    PTR32 tensorCaptureReplayOpaqueDataSize;
+} VkPhysicalDeviceDescriptorHeapTensorPropertiesARM32;
+
 typedef struct VkPhysicalDeviceDescriptorIndexingFeatures32
 {
     VkStructureType sType;
@@ -5537,6 +5778,13 @@ typedef struct VkPhysicalDeviceInlineUniformBlockProperties32
 } VkPhysicalDeviceInlineUniformBlockProperties32;
 typedef VkPhysicalDeviceInlineUniformBlockProperties32 VkPhysicalDeviceInlineUniformBlockPropertiesEXT32;
 
+typedef struct VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 internallySynchronizedQueues;
+} VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32;
+
 typedef struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32
 {
     VkStructureType sType;
@@ -6244,6 +6492,23 @@ typedef struct VkPhysicalDeviceProvokingVertexPropertiesEXT32
     VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
 } VkPhysicalDeviceProvokingVertexPropertiesEXT32;
 
+typedef struct VkPhysicalDevicePushConstantBankFeaturesNV32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 pushConstantBank;
+} VkPhysicalDevicePushConstantBankFeaturesNV32;
+
+typedef struct VkPhysicalDevicePushConstantBankPropertiesNV32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t maxGraphicsPushConstantBanks;
+    uint32_t maxComputePushConstantBanks;
+    uint32_t maxGraphicsPushDataBanks;
+    uint32_t maxComputePushDataBanks;
+} VkPhysicalDevicePushConstantBankPropertiesNV32;
+
 typedef struct VkPhysicalDevicePushDescriptorProperties32
 {
     VkStructureType sType;
@@ -6859,6 +7124,13 @@ typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32
 } VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32;
 typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR32;
 
+typedef struct VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 shaderSubgroupPartitioned;
+} VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32;
+
 typedef struct VkPhysicalDeviceShaderSubgroupRotateFeatures32
 {
     VkStructureType sType;
@@ -8091,6 +8363,13 @@ typedef struct VkProtectedSubmitInfo32
     VkBool32 protectedSubmit;
 } VkProtectedSubmitInfo32;
 
+typedef struct VkPushConstantBankInfoNV32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t bank;
+} VkPushConstantBankInfoNV32;
+
 typedef struct VkPushConstantsInfo32
 {
     VkStructureType sType;
@@ -8103,6 +8382,14 @@ typedef struct VkPushConstantsInfo32
 } VkPushConstantsInfo32;
 typedef VkPushConstantsInfo32 VkPushConstantsInfoKHR32;
 
+typedef struct VkPushDataInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t offset;
+    VkHostAddressRangeConstEXT32 data;
+} VkPushDataInfoEXT32;
+
 typedef struct VkPushDescriptorSetInfo32
 {
     VkStructureType sType;
@@ -8553,6 +8840,14 @@ typedef struct VkResolveImageModeInfoKHR32
     VkResolveModeFlagBits stencilResolveMode;
 } VkResolveImageModeInfoKHR32;
 
+typedef struct VkResourceDescriptorInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkDescriptorType type;
+    VkResourceDescriptorDataEXT32 data;
+} VkResourceDescriptorInfoEXT32;
+
 typedef struct VkSamplerBlockMatchWindowCreateInfoQCOM32
 {
     VkStructureType sType;
@@ -8576,28 +8871,6 @@ typedef struct VkSamplerCaptureDescriptorDataInfoEXT32
     VkSampler DECLSPEC_ALIGN(8) sampler;
 } VkSamplerCaptureDescriptorDataInfoEXT32;
 
-typedef struct VkSamplerCreateInfo32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkSamplerCreateFlags flags;
-    VkFilter magFilter;
-    VkFilter minFilter;
-    VkSamplerMipmapMode mipmapMode;
-    VkSamplerAddressMode addressModeU;
-    VkSamplerAddressMode addressModeV;
-    VkSamplerAddressMode addressModeW;
-    float mipLodBias;
-    VkBool32 anisotropyEnable;
-    float maxAnisotropy;
-    VkBool32 compareEnable;
-    VkCompareOp compareOp;
-    float minLod;
-    float maxLod;
-    VkBorderColor borderColor;
-    VkBool32 unnormalizedCoordinates;
-} VkSamplerCreateInfo32;
-
 typedef struct VkSamplerCubicWeightsCreateInfoQCOM32
 {
     VkStructureType sType;
@@ -8613,6 +8886,13 @@ typedef struct VkSamplerCustomBorderColorCreateInfoEXT32
     VkFormat format;
 } VkSamplerCustomBorderColorCreateInfoEXT32;
 
+typedef struct VkSamplerCustomBorderColorIndexCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t index;
+} VkSamplerCustomBorderColorIndexCreateInfoEXT32;
+
 typedef struct VkSamplerReductionModeCreateInfo32
 {
     VkStructureType sType;
@@ -8742,6 +9022,14 @@ typedef struct VkShaderCreateInfoEXT32
     PTR32 pSpecializationInfo;
 } VkShaderCreateInfoEXT32;
 
+typedef struct VkShaderDescriptorSetAndBindingMappingInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t mappingCount;
+    PTR32 pMappings;
+} VkShaderDescriptorSetAndBindingMappingInfoEXT32;
+
 typedef struct VkShaderModuleCreateInfo32
 {
     VkStructureType sType;
@@ -8866,6 +9154,13 @@ typedef struct VkSubresourceLayout232
 typedef VkSubresourceLayout232 VkSubresourceLayout2KHR32;
 typedef VkSubresourceLayout232 VkSubresourceLayout2EXT32;
 
+typedef struct VkSubsampledImageFormatPropertiesEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t subsampledImageDescriptorCount;
+} VkSubsampledImageFormatPropertiesEXT32;
+
 typedef struct VkSurfaceCapabilities2KHR32
 {
     VkStructureType sType;
@@ -9040,15 +9335,6 @@ typedef struct VkTensorViewCaptureDescriptorDataInfoARM32
     VkTensorViewARM DECLSPEC_ALIGN(8) tensorView;
 } VkTensorViewCaptureDescriptorDataInfoARM32;
 
-typedef struct VkTensorViewCreateInfoARM32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkTensorViewCreateFlagsARM DECLSPEC_ALIGN(8) flags;
-    VkTensorARM DECLSPEC_ALIGN(8) tensor;
-    VkFormat format;
-} VkTensorViewCreateInfoARM32;
-
 typedef struct VkTextureLODGatherFormatPropertiesAMD32
 {
     VkStructureType sType;
@@ -10462,6 +10748,18 @@ static void convert_VkCommandBufferInheritanceInfo_win64_to_host(struct conversi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_DESCRIPTOR_HEAP_INFO_EXT:
+        {
+            VkCommandBufferInheritanceDescriptorHeapInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkCommandBufferInheritanceDescriptorHeapInfoEXT *in_ext = (const VkCommandBufferInheritanceDescriptorHeapInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_DESCRIPTOR_HEAP_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pSamplerHeapBindInfo = in_ext->pSamplerHeapBindInfo;
+            out_ext->pResourceHeapBindInfo = in_ext->pResourceHeapBindInfo;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
         {
             VkCommandBufferInheritanceRenderPassTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -10606,6 +10904,43 @@ static void convert_VkCommandBufferBeginInfo_win64_to_host(struct conversion_con
 }
 #endif /* _WIN64 */
 
+static void convert_VkDeviceAddressRangeEXT_win32_to_host(const VkDeviceAddressRangeEXT32 *in, VkDeviceAddressRangeEXT *out)
+{
+    if (!in) return;
+
+    out->address = in->address;
+    out->size = in->size;
+}
+
+static void convert_VkBindHeapInfoEXT_win32_to_host(const VkBindHeapInfoEXT32 *in, VkBindHeapInfoEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    convert_VkDeviceAddressRangeEXT_win32_to_host(&in->heapRange, &out->heapRange);
+    out->reservedRangeOffset = in->reservedRangeOffset;
+    out->reservedRangeSize = in->reservedRangeSize;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static const VkBindHeapInfoEXT *convert_VkBindHeapInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkBindHeapInfoEXT32 *in, uint32_t count)
+{
+    VkBindHeapInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkBindHeapInfoEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static void convert_VkCommandBufferInheritanceInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo32 *in, VkCommandBufferInheritanceInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -10650,6 +10985,18 @@ static void convert_VkCommandBufferInheritanceInfo_win32_to_host(struct conversi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_DESCRIPTOR_HEAP_INFO_EXT:
+        {
+            VkCommandBufferInheritanceDescriptorHeapInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkCommandBufferInheritanceDescriptorHeapInfoEXT32 *in_ext = (const VkCommandBufferInheritanceDescriptorHeapInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_DESCRIPTOR_HEAP_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pSamplerHeapBindInfo = convert_VkBindHeapInfoEXT_array_win32_to_host(ctx, (const VkBindHeapInfoEXT32 *)UlongToPtr(in_ext->pSamplerHeapBindInfo), 1);
+            out_ext->pResourceHeapBindInfo = convert_VkBindHeapInfoEXT_array_win32_to_host(ctx, (const VkBindHeapInfoEXT32 *)UlongToPtr(in_ext->pResourceHeapBindInfo), 1);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
         {
             VkCommandBufferInheritanceRenderPassTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -14796,6 +15143,59 @@ static void convert_VkPushConstantsInfo_win32_to_host(struct conversion_context
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV:
+        {
+            VkPushConstantBankInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPushConstantBankInfoNV32 *in_ext = (const VkPushConstantBankInfoNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV;
+            out_ext->pNext = NULL;
+            out_ext->bank = in_ext->bank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+
+static void convert_VkHostAddressRangeConstEXT_win32_to_host(const VkHostAddressRangeConstEXT32 *in, VkHostAddressRangeConstEXT *out)
+{
+    if (!in) return;
+
+    out->address = UlongToPtr(in->address);
+    out->size = in->size;
+}
+
+static void convert_VkPushDataInfoEXT_win32_to_host(struct conversion_context *ctx, const VkPushDataInfoEXT32 *in, VkPushDataInfoEXT *out)
+{
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->offset = in->offset;
+    convert_VkHostAddressRangeConstEXT_win32_to_host(&in->data, &out->data);
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV:
+        {
+            VkPushConstantBankInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPushConstantBankInfoNV32 *in_ext = (const VkPushConstantBankInfoNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV;
+            out_ext->pNext = NULL;
+            out_ext->bank = in_ext->bank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         default:
             FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
@@ -15999,6 +16399,318 @@ static void convert_VkCommandPoolCreateInfo_win32_to_host(struct conversion_cont
     }
 }
 
+#ifdef _WIN64
+static void convert_VkSamplerCreateInfo_win64_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo *in, VkSamplerCreateInfo *out)
+{
+    const VkBaseInStructure *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->flags = in->flags;
+    out->magFilter = in->magFilter;
+    out->minFilter = in->minFilter;
+    out->mipmapMode = in->mipmapMode;
+    out->addressModeU = in->addressModeU;
+    out->addressModeV = in->addressModeV;
+    out->addressModeW = in->addressModeW;
+    out->mipLodBias = in->mipLodBias;
+    out->anisotropyEnable = in->anisotropyEnable;
+    out->maxAnisotropy = in->maxAnisotropy;
+    out->compareEnable = in->compareEnable;
+    out->compareOp = in->compareOp;
+    out->minLod = in->minLod;
+    out->maxLod = in->maxLod;
+    out->borderColor = in->borderColor;
+    out->unnormalizedCoordinates = in->unnormalizedCoordinates;
+
+    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
+        {
+            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDebugUtilsObjectNameInfoEXT *in_ext = (const VkDebugUtilsObjectNameInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->objectType = in_ext->objectType;
+            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
+            out_ext->pObjectName = in_ext->pObjectName;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
+        {
+            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
+        {
+            VkSamplerBlockMatchWindowCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerBlockMatchWindowCreateInfoQCOM *in_ext = (const VkSamplerBlockMatchWindowCreateInfoQCOM *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
+            out_ext->pNext = NULL;
+            out_ext->windowExtent = in_ext->windowExtent;
+            out_ext->windowCompareMode = in_ext->windowCompareMode;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
+        {
+            VkSamplerBorderColorComponentMappingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerBorderColorComponentMappingCreateInfoEXT *in_ext = (const VkSamplerBorderColorComponentMappingCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->components = in_ext->components;
+            out_ext->srgb = in_ext->srgb;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
+        {
+            VkSamplerCubicWeightsCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCubicWeightsCreateInfoQCOM *in_ext = (const VkSamplerCubicWeightsCreateInfoQCOM *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
+            out_ext->pNext = NULL;
+            out_ext->cubicWeights = in_ext->cubicWeights;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
+        {
+            VkSamplerCustomBorderColorCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCustomBorderColorCreateInfoEXT *in_ext = (const VkSamplerCustomBorderColorCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->customBorderColor = in_ext->customBorderColor;
+            out_ext->format = in_ext->format;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_INDEX_CREATE_INFO_EXT:
+        {
+            VkSamplerCustomBorderColorIndexCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCustomBorderColorIndexCreateInfoEXT *in_ext = (const VkSamplerCustomBorderColorIndexCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_INDEX_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->index = in_ext->index;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
+        {
+            VkSamplerReductionModeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerReductionModeCreateInfo *in_ext = (const VkSamplerReductionModeCreateInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
+            out_ext->pNext = NULL;
+            out_ext->reductionMode = in_ext->reductionMode;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
+        {
+            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerYcbcrConversionInfo *in_ext = (const VkSamplerYcbcrConversionInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
+            out_ext->pNext = NULL;
+            out_ext->conversion = in_ext->conversion;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static const VkSamplerCreateInfo *convert_VkSamplerCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo *in, uint32_t count)
+{
+    VkSamplerCreateInfo *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkSamplerCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourceConstantOffsetEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceConstantOffsetEXT *in, VkDescriptorMappingSourceConstantOffsetEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, in->pEmbeddedSampler, 1);
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourcePushIndexEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourcePushIndexEXT *in, VkDescriptorMappingSourcePushIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, in->pEmbeddedSampler, 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourceIndirectIndexEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceIndirectIndexEXT *in, VkDescriptorMappingSourceIndirectIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->addressOffset = in->addressOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, in->pEmbeddedSampler, 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerAddressOffset = in->samplerAddressOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourceIndirectIndexArrayEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceIndirectIndexArrayEXT *in, VkDescriptorMappingSourceIndirectIndexArrayEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->addressOffset = in->addressOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, in->pEmbeddedSampler, 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerAddressOffset = in->samplerAddressOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourceShaderRecordIndexEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceShaderRecordIndexEXT *in, VkDescriptorMappingSourceShaderRecordIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->shaderRecordOffset = in->shaderRecordOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, in->pEmbeddedSampler, 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerShaderRecordOffset = in->samplerShaderRecordOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorMappingSourceDataEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceDataEXT *in, VkDescriptorMappingSourceDataEXT *out, VkFlags selector)
+{
+    if (!in) return;
+
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_CONSTANT_OFFSET_EXT)
+        convert_VkDescriptorMappingSourceConstantOffsetEXT_win64_to_host(ctx, &in->constantOffset, &out->constantOffset);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_PUSH_INDEX_EXT)
+        convert_VkDescriptorMappingSourcePushIndexEXT_win64_to_host(ctx, &in->pushIndex, &out->pushIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_EXT)
+        convert_VkDescriptorMappingSourceIndirectIndexEXT_win64_to_host(ctx, &in->indirectIndex, &out->indirectIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_ARRAY_EXT)
+        convert_VkDescriptorMappingSourceIndirectIndexArrayEXT_win64_to_host(ctx, &in->indirectIndexArray, &out->indirectIndexArray);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_RESOURCE_HEAP_DATA_EXT)
+        out->heapData = in->heapData;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_DATA_EXT)
+        out->pushDataOffset = in->pushDataOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_ADDRESS_EXT)
+        out->pushAddressOffset = in->pushAddressOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_INDIRECT_ADDRESS_EXT)
+        out->indirectAddress = in->indirectAddress;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_SHADER_RECORD_INDEX_EXT)
+        convert_VkDescriptorMappingSourceShaderRecordIndexEXT_win64_to_host(ctx, &in->shaderRecordIndex, &out->shaderRecordIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_DATA_EXT)
+        out->shaderRecordDataOffset = in->shaderRecordDataOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_ADDRESS_EXT)
+        out->shaderRecordAddressOffset = in->shaderRecordAddressOffset;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static void convert_VkDescriptorSetAndBindingMappingEXT_win64_to_host(struct conversion_context *ctx, const VkDescriptorSetAndBindingMappingEXT *in, VkDescriptorSetAndBindingMappingEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->descriptorSet = in->descriptorSet;
+    out->firstBinding = in->firstBinding;
+    out->bindingCount = in->bindingCount;
+    out->resourceMask = in->resourceMask;
+    out->source = in->source;
+    convert_VkDescriptorMappingSourceDataEXT_win64_to_host(ctx, &in->sourceData, &out->sourceData, in->source);
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static const VkDescriptorSetAndBindingMappingEXT *convert_VkDescriptorSetAndBindingMappingEXT_array_win64_to_host(struct conversion_context *ctx, const VkDescriptorSetAndBindingMappingEXT *in, uint32_t count)
+{
+    VkDescriptorSetAndBindingMappingEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDescriptorSetAndBindingMappingEXT_win64_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+#endif /* _WIN64 */
+
 #ifdef _WIN64
 static void convert_VkPipelineShaderStageCreateInfo_win64_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo *in, VkPipelineShaderStageCreateInfo *out)
 {
@@ -16069,6 +16781,18 @@ static void convert_VkPipelineShaderStageCreateInfo_win64_to_host(struct convers
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT:
+        {
+            VkShaderDescriptorSetAndBindingMappingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkShaderDescriptorSetAndBindingMappingInfoEXT *in_ext = (const VkShaderDescriptorSetAndBindingMappingInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->mappingCount = in_ext->mappingCount;
+            out_ext->pMappings = convert_VkDescriptorSetAndBindingMappingEXT_array_win64_to_host(ctx, in_ext->pMappings, in_ext->mappingCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
         {
             VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -16185,6 +16909,322 @@ static const VkSpecializationInfo *convert_VkSpecializationInfo_array_win32_to_h
     return out;
 }
 
+static void convert_VkSamplerCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo32 *in, VkSamplerCreateInfo *out)
+{
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->flags = in->flags;
+    out->magFilter = in->magFilter;
+    out->minFilter = in->minFilter;
+    out->mipmapMode = in->mipmapMode;
+    out->addressModeU = in->addressModeU;
+    out->addressModeV = in->addressModeV;
+    out->addressModeW = in->addressModeW;
+    out->mipLodBias = in->mipLodBias;
+    out->anisotropyEnable = in->anisotropyEnable;
+    out->maxAnisotropy = in->maxAnisotropy;
+    out->compareEnable = in->compareEnable;
+    out->compareOp = in->compareOp;
+    out->minLod = in->minLod;
+    out->maxLod = in->maxLod;
+    out->borderColor = in->borderColor;
+    out->unnormalizedCoordinates = in->unnormalizedCoordinates;
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
+        {
+            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDebugUtilsObjectNameInfoEXT32 *in_ext = (const VkDebugUtilsObjectNameInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->objectType = in_ext->objectType;
+            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
+            out_ext->pObjectName = UlongToPtr(in_ext->pObjectName);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
+        {
+            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
+        {
+            VkSamplerBlockMatchWindowCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerBlockMatchWindowCreateInfoQCOM32 *in_ext = (const VkSamplerBlockMatchWindowCreateInfoQCOM32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
+            out_ext->pNext = NULL;
+            out_ext->windowExtent = in_ext->windowExtent;
+            out_ext->windowCompareMode = in_ext->windowCompareMode;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
+        {
+            VkSamplerBorderColorComponentMappingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *in_ext = (const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->components = in_ext->components;
+            out_ext->srgb = in_ext->srgb;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
+        {
+            VkSamplerCubicWeightsCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCubicWeightsCreateInfoQCOM32 *in_ext = (const VkSamplerCubicWeightsCreateInfoQCOM32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
+            out_ext->pNext = NULL;
+            out_ext->cubicWeights = in_ext->cubicWeights;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
+        {
+            VkSamplerCustomBorderColorCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCustomBorderColorCreateInfoEXT32 *in_ext = (const VkSamplerCustomBorderColorCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->customBorderColor = in_ext->customBorderColor;
+            out_ext->format = in_ext->format;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_INDEX_CREATE_INFO_EXT:
+        {
+            VkSamplerCustomBorderColorIndexCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerCustomBorderColorIndexCreateInfoEXT32 *in_ext = (const VkSamplerCustomBorderColorIndexCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_INDEX_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->index = in_ext->index;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
+        {
+            VkSamplerReductionModeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerReductionModeCreateInfo32 *in_ext = (const VkSamplerReductionModeCreateInfo32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
+            out_ext->pNext = NULL;
+            out_ext->reductionMode = in_ext->reductionMode;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
+        {
+            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
+            out_ext->pNext = NULL;
+            out_ext->conversion = in_ext->conversion;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+
+static const VkSamplerCreateInfo *convert_VkSamplerCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo32 *in, uint32_t count)
+{
+    VkSamplerCreateInfo *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkSamplerCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static void convert_VkDescriptorMappingSourceConstantOffsetEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceConstantOffsetEXT32 *in, VkDescriptorMappingSourceConstantOffsetEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(in->pEmbeddedSampler), 1);
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+
+static void convert_VkDescriptorMappingSourcePushIndexEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourcePushIndexEXT32 *in, VkDescriptorMappingSourcePushIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(in->pEmbeddedSampler), 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+
+static void convert_VkDescriptorMappingSourceIndirectIndexEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceIndirectIndexEXT32 *in, VkDescriptorMappingSourceIndirectIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->addressOffset = in->addressOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(in->pEmbeddedSampler), 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerAddressOffset = in->samplerAddressOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+
+static void convert_VkDescriptorMappingSourceIndirectIndexArrayEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceIndirectIndexArrayEXT32 *in, VkDescriptorMappingSourceIndirectIndexArrayEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->pushOffset = in->pushOffset;
+    out->addressOffset = in->addressOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(in->pEmbeddedSampler), 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerPushOffset = in->samplerPushOffset;
+    out->samplerAddressOffset = in->samplerAddressOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+}
+
+static void convert_VkDescriptorMappingSourceShaderRecordIndexEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceShaderRecordIndexEXT32 *in, VkDescriptorMappingSourceShaderRecordIndexEXT *out)
+{
+    if (!in) return;
+
+    out->heapOffset = in->heapOffset;
+    out->shaderRecordOffset = in->shaderRecordOffset;
+    out->heapIndexStride = in->heapIndexStride;
+    out->heapArrayStride = in->heapArrayStride;
+    out->pEmbeddedSampler = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(in->pEmbeddedSampler), 1);
+    out->useCombinedImageSamplerIndex = in->useCombinedImageSamplerIndex;
+    out->samplerHeapOffset = in->samplerHeapOffset;
+    out->samplerShaderRecordOffset = in->samplerShaderRecordOffset;
+    out->samplerHeapIndexStride = in->samplerHeapIndexStride;
+    out->samplerHeapArrayStride = in->samplerHeapArrayStride;
+}
+
+static void convert_VkDescriptorMappingSourceDataEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorMappingSourceDataEXT32 *in, VkDescriptorMappingSourceDataEXT *out, VkFlags selector)
+{
+    if (!in) return;
+
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_CONSTANT_OFFSET_EXT)
+        convert_VkDescriptorMappingSourceConstantOffsetEXT_win32_to_host(ctx, &in->constantOffset, &out->constantOffset);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_PUSH_INDEX_EXT)
+        convert_VkDescriptorMappingSourcePushIndexEXT_win32_to_host(ctx, &in->pushIndex, &out->pushIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_EXT)
+        convert_VkDescriptorMappingSourceIndirectIndexEXT_win32_to_host(ctx, &in->indirectIndex, &out->indirectIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_ARRAY_EXT)
+        convert_VkDescriptorMappingSourceIndirectIndexArrayEXT_win32_to_host(ctx, &in->indirectIndexArray, &out->indirectIndexArray);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_RESOURCE_HEAP_DATA_EXT)
+        out->heapData = in->heapData;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_DATA_EXT)
+        out->pushDataOffset = in->pushDataOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_ADDRESS_EXT)
+        out->pushAddressOffset = in->pushAddressOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_INDIRECT_ADDRESS_EXT)
+        out->indirectAddress = in->indirectAddress;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_SHADER_RECORD_INDEX_EXT)
+        convert_VkDescriptorMappingSourceShaderRecordIndexEXT_win32_to_host(ctx, &in->shaderRecordIndex, &out->shaderRecordIndex);
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_DATA_EXT)
+        out->shaderRecordDataOffset = in->shaderRecordDataOffset;
+    if (selector == VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_ADDRESS_EXT)
+        out->shaderRecordAddressOffset = in->shaderRecordAddressOffset;
+}
+
+static void convert_VkDescriptorSetAndBindingMappingEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetAndBindingMappingEXT32 *in, VkDescriptorSetAndBindingMappingEXT *out)
+{
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->descriptorSet = in->descriptorSet;
+    out->firstBinding = in->firstBinding;
+    out->bindingCount = in->bindingCount;
+    out->resourceMask = in->resourceMask;
+    out->source = in->source;
+    convert_VkDescriptorMappingSourceDataEXT_win32_to_host(ctx, &in->sourceData, &out->sourceData, in->source);
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV:
+        {
+            VkPushConstantBankInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPushConstantBankInfoNV32 *in_ext = (const VkPushConstantBankInfoNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV;
+            out_ext->pNext = NULL;
+            out_ext->bank = in_ext->bank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+
+static const VkDescriptorSetAndBindingMappingEXT *convert_VkDescriptorSetAndBindingMappingEXT_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetAndBindingMappingEXT32 *in, uint32_t count)
+{
+    VkDescriptorSetAndBindingMappingEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDescriptorSetAndBindingMappingEXT_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static void convert_VkPipelineShaderStageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo32 *in, VkPipelineShaderStageCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -16254,6 +17294,18 @@ static void convert_VkPipelineShaderStageCreateInfo_win32_to_host(struct convers
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT:
+        {
+            VkShaderDescriptorSetAndBindingMappingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkShaderDescriptorSetAndBindingMappingInfoEXT32 *in_ext = (const VkShaderDescriptorSetAndBindingMappingInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->mappingCount = in_ext->mappingCount;
+            out_ext->pMappings = convert_VkDescriptorSetAndBindingMappingEXT_array_win32_to_host(ctx, (const VkDescriptorSetAndBindingMappingEXT32 *)UlongToPtr(in_ext->pMappings), in_ext->mappingCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
         {
             VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -17708,6 +18760,18 @@ static void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceDescriptorHeapFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorHeapFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->descriptorHeap = in_ext->descriptorHeap;
+            out_ext->descriptorHeapCaptureReplay = in_ext->descriptorHeapCaptureReplay;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
         {
             VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -18270,6 +19334,17 @@ static void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR:
+        {
+            VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *in_ext = (const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR;
+            out_ext->pNext = NULL;
+            out_ext->internallySynchronizedQueues = in_ext->internallySynchronizedQueues;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
         {
             VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -18853,6 +19928,17 @@ static void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV:
+        {
+            VkPhysicalDevicePushConstantBankFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePushConstantBankFeaturesNV *in_ext = (const VkPhysicalDevicePushConstantBankFeaturesNV *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV;
+            out_ext->pNext = NULL;
+            out_ext->pushConstantBank = in_ext->pushConstantBank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
         {
             VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -19434,6 +20520,17 @@ static void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT:
+        {
+            VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->shaderSubgroupPartitioned = in_ext->shaderSubgroupPartitioned;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
         {
             VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -20758,6 +21855,18 @@ static void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceDescriptorHeapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorHeapFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->descriptorHeap = in_ext->descriptorHeap;
+            out_ext->descriptorHeapCaptureReplay = in_ext->descriptorHeapCaptureReplay;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
         {
             VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -21320,6 +22429,17 @@ static void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR:
+        {
+            VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32 *in_ext = (const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR;
+            out_ext->pNext = NULL;
+            out_ext->internallySynchronizedQueues = in_ext->internallySynchronizedQueues;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
         {
             VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -21903,6 +23023,17 @@ static void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV:
+        {
+            VkPhysicalDevicePushConstantBankFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePushConstantBankFeaturesNV32 *in_ext = (const VkPhysicalDevicePushConstantBankFeaturesNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV;
+            out_ext->pNext = NULL;
+            out_ext->pushConstantBank = in_ext->pushConstantBank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
         {
             VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -22484,6 +23615,17 @@ static void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT:
+        {
+            VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->shaderSubgroupPartitioned = in_ext->shaderSubgroupPartitioned;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
         {
             VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -24712,6 +25854,17 @@ static void convert_VkImageCreateInfo_win64_to_host(struct conversion_context *c
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT:
+        {
+            VkOpaqueCaptureDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkOpaqueCaptureDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDataCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pData = in_ext->pData;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
         {
             VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -24754,6 +25907,22 @@ static void convert_VkImageCreateInfo_win64_to_host(struct conversion_context *c
 }
 #endif /* _WIN64 */
 
+static const VkHostAddressRangeConstEXT *convert_VkHostAddressRangeConstEXT_array_win32_to_host(struct conversion_context *ctx, const VkHostAddressRangeConstEXT32 *in, uint32_t count)
+{
+    VkHostAddressRangeConstEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkHostAddressRangeConstEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, VkImageCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -24861,6 +26030,17 @@ static void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *c
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT:
+        {
+            VkOpaqueCaptureDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkOpaqueCaptureDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDataCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pData = convert_VkHostAddressRangeConstEXT_array_win32_to_host(ctx, (const VkHostAddressRangeConstEXT32 *)UlongToPtr(in_ext->pData), 1);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
         {
             VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -25013,7 +26193,7 @@ static void convert_VkIndirectCommandsTokenDataEXT_win32_to_host(const VkIndirec
 {
     if (!in) return;
 
-    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT || selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT)
+    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT || selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT || selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT || selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT)
         out->pPushConstant = UlongToPtr(in->pPushConstant);
     if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT)
         out->pVertexBuffer = UlongToPtr(in->pVertexBuffer);
@@ -25023,8 +26203,11 @@ static void convert_VkIndirectCommandsTokenDataEXT_win32_to_host(const VkIndirec
         out->pExecutionSet = UlongToPtr(in->pExecutionSet);
 }
 
-static void convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(const VkIndirectCommandsLayoutTokenEXT32 *in, VkIndirectCommandsLayoutTokenEXT *out)
+static void convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenEXT32 *in, VkIndirectCommandsLayoutTokenEXT *out)
 {
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
     if (!in) return;
 
     out->sType = in->sType;
@@ -25032,8 +26215,27 @@ static void convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(const VkIndir
     out->type = in->type;
     convert_VkIndirectCommandsTokenDataEXT_win32_to_host(&in->data, &out->data, in->type);
     out->offset = in->offset;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV:
+        {
+            VkPushConstantBankInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPushConstantBankInfoNV32 *in_ext = (const VkPushConstantBankInfoNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV;
+            out_ext->pNext = NULL;
+            out_ext->bank = in_ext->bank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
 }
 
 static const VkIndirectCommandsLayoutTokenEXT *convert_VkIndirectCommandsLayoutTokenEXT_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenEXT32 *in, uint32_t count)
@@ -25046,7 +26248,7 @@ static const VkIndirectCommandsLayoutTokenEXT *convert_VkIndirectCommandsLayoutT
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(&in[i], &out[i]);
+        convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
@@ -25094,8 +26296,11 @@ static void convert_VkIndirectCommandsLayoutCreateInfoEXT_win32_to_host(struct c
     }
 }
 
-static void convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(const VkIndirectCommandsLayoutTokenNV32 *in, VkIndirectCommandsLayoutTokenNV *out)
+static void convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenNV32 *in, VkIndirectCommandsLayoutTokenNV *out)
 {
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
     if (!in) return;
 
     out->sType = in->sType;
@@ -25113,8 +26318,28 @@ static void convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(const VkIndire
     out->indexTypeCount = in->indexTypeCount;
     out->pIndexTypes = UlongToPtr(in->pIndexTypes);
     out->pIndexTypeValues = UlongToPtr(in->pIndexTypeValues);
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_PUSH_DATA_TOKEN_NV:
+        {
+            VkIndirectCommandsLayoutPushDataTokenNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkIndirectCommandsLayoutPushDataTokenNV32 *in_ext = (const VkIndirectCommandsLayoutPushDataTokenNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_PUSH_DATA_TOKEN_NV;
+            out_ext->pNext = NULL;
+            out_ext->pushDataOffset = in_ext->pushDataOffset;
+            out_ext->pushDataSize = in_ext->pushDataSize;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
 }
 
 static const VkIndirectCommandsLayoutTokenNV *convert_VkIndirectCommandsLayoutTokenNV_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenNV32 *in, uint32_t count)
@@ -25127,7 +26352,7 @@ static const VkIndirectCommandsLayoutTokenNV *convert_VkIndirectCommandsLayoutTo
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(&in[i], &out[i]);
+        convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
@@ -26849,123 +28074,6 @@ static void convert_VkRenderPassCreateInfo2_win32_to_host(struct conversion_cont
     }
 }
 
-static void convert_VkSamplerCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo32 *in, VkSamplerCreateInfo *out)
-{
-    const VkBaseInStructure32 *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-    out->magFilter = in->magFilter;
-    out->minFilter = in->minFilter;
-    out->mipmapMode = in->mipmapMode;
-    out->addressModeU = in->addressModeU;
-    out->addressModeV = in->addressModeV;
-    out->addressModeW = in->addressModeW;
-    out->mipLodBias = in->mipLodBias;
-    out->anisotropyEnable = in->anisotropyEnable;
-    out->maxAnisotropy = in->maxAnisotropy;
-    out->compareEnable = in->compareEnable;
-    out->compareOp = in->compareOp;
-    out->minLod = in->minLod;
-    out->maxLod = in->maxLod;
-    out->borderColor = in->borderColor;
-    out->unnormalizedCoordinates = in->unnormalizedCoordinates;
-
-    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
-        {
-            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
-        {
-            VkSamplerBlockMatchWindowCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerBlockMatchWindowCreateInfoQCOM32 *in_ext = (const VkSamplerBlockMatchWindowCreateInfoQCOM32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
-            out_ext->pNext = NULL;
-            out_ext->windowExtent = in_ext->windowExtent;
-            out_ext->windowCompareMode = in_ext->windowCompareMode;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
-        {
-            VkSamplerBorderColorComponentMappingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *in_ext = (const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->components = in_ext->components;
-            out_ext->srgb = in_ext->srgb;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
-        {
-            VkSamplerCubicWeightsCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerCubicWeightsCreateInfoQCOM32 *in_ext = (const VkSamplerCubicWeightsCreateInfoQCOM32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
-            out_ext->pNext = NULL;
-            out_ext->cubicWeights = in_ext->cubicWeights;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
-        {
-            VkSamplerCustomBorderColorCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerCustomBorderColorCreateInfoEXT32 *in_ext = (const VkSamplerCustomBorderColorCreateInfoEXT32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->customBorderColor = in_ext->customBorderColor;
-            out_ext->format = in_ext->format;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
-        {
-            VkSamplerReductionModeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerReductionModeCreateInfo32 *in_ext = (const VkSamplerReductionModeCreateInfo32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->reductionMode = in_ext->reductionMode;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
-        {
-            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
-            out_ext->pNext = NULL;
-            out_ext->conversion = in_ext->conversion;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-
 static void convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerYcbcrConversionCreateInfo32 *in, VkSamplerYcbcrConversionCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -27196,6 +28304,111 @@ static void convert_VkShaderModuleCreateInfo_win32_to_host(struct conversion_con
     }
 }
 
+#ifdef _WIN64
+static void convert_VkShaderCreateInfoEXT_win64_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT *in, VkShaderCreateInfoEXT *out)
+{
+    const VkBaseInStructure *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->flags = in->flags;
+    out->stage = in->stage;
+    out->nextStage = in->nextStage;
+    out->codeType = in->codeType;
+    out->codeSize = in->codeSize;
+    out->pCode = in->pCode;
+    out->pName = in->pName;
+    out->setLayoutCount = in->setLayoutCount;
+    out->pSetLayouts = in->pSetLayouts;
+    out->pushConstantRangeCount = in->pushConstantRangeCount;
+    out->pPushConstantRanges = in->pPushConstantRanges;
+    out->pSpecializationInfo = in->pSpecializationInfo;
+
+    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT:
+        {
+            VkCustomResolveCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkCustomResolveCreateInfoEXT *in_ext = (const VkCustomResolveCreateInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->customResolve = in_ext->customResolve;
+            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
+            out_ext->pColorAttachmentFormats = in_ext->pColorAttachmentFormats;
+            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
+            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
+        {
+            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
+            out_ext->pNext = NULL;
+            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT:
+        {
+            VkShaderDescriptorSetAndBindingMappingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkShaderDescriptorSetAndBindingMappingInfoEXT *in_ext = (const VkShaderDescriptorSetAndBindingMappingInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->mappingCount = in_ext->mappingCount;
+            out_ext->pMappings = convert_VkDescriptorSetAndBindingMappingEXT_array_win64_to_host(ctx, in_ext->pMappings, in_ext->mappingCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
+        {
+            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkValidationFeaturesEXT *in_ext = (const VkValidationFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
+            out_ext->pEnabledValidationFeatures = in_ext->pEnabledValidationFeatures;
+            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
+            out_ext->pDisabledValidationFeatures = in_ext->pDisabledValidationFeatures;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static const VkShaderCreateInfoEXT *convert_VkShaderCreateInfoEXT_array_win64_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT *in, uint32_t count)
+{
+    VkShaderCreateInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkShaderCreateInfoEXT_win64_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+#endif /* _WIN64 */
+
 static void convert_VkShaderCreateInfoEXT_win32_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT32 *in, VkShaderCreateInfoEXT *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -27248,6 +28461,18 @@ static void convert_VkShaderCreateInfoEXT_win32_to_host(struct conversion_contex
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT:
+        {
+            VkShaderDescriptorSetAndBindingMappingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkShaderDescriptorSetAndBindingMappingInfoEXT32 *in_ext = (const VkShaderDescriptorSetAndBindingMappingInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->mappingCount = in_ext->mappingCount;
+            out_ext->pMappings = convert_VkDescriptorSetAndBindingMappingEXT_array_win32_to_host(ctx, (const VkDescriptorSetAndBindingMappingEXT32 *)UlongToPtr(in_ext->pMappings), in_ext->mappingCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
         {
             VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -27467,6 +28692,17 @@ static void convert_VkTensorCreateInfoARM_win32_to_host(struct conversion_contex
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT:
+        {
+            VkOpaqueCaptureDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkOpaqueCaptureDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDataCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pData = convert_VkHostAddressRangeConstEXT_array_win32_to_host(ctx, (const VkHostAddressRangeConstEXT32 *)UlongToPtr(in_ext->pData), 1);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
         {
             VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -29631,6 +30867,50 @@ static void convert_VkImageMemoryRequirementsInfo2_win32_to_host(struct conversi
     }
 }
 
+static void convert_VkHostAddressRangeEXT_win32_to_host(const VkHostAddressRangeEXT32 *in, VkHostAddressRangeEXT *out)
+{
+    if (!in) return;
+
+    out->address = UlongToPtr(in->address);
+    out->size = in->size;
+}
+
+static VkHostAddressRangeEXT *convert_VkHostAddressRangeEXT_array_win32_to_host(struct conversion_context *ctx, const VkHostAddressRangeEXT32 *in, uint32_t count)
+{
+    VkHostAddressRangeEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkHostAddressRangeEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static void convert_VkHostAddressRangeEXT_host_to_win32(const VkHostAddressRangeEXT *in, VkHostAddressRangeEXT32 *out)
+{
+    if (!in) return;
+
+    out->address = PtrToUlong(in->address);
+    out->size = in->size;
+}
+
+static void convert_VkHostAddressRangeEXT_array_host_to_win32(const VkHostAddressRangeEXT *in, VkHostAddressRangeEXT32 *out, uint32_t count)
+{
+    unsigned int i;
+
+    if (!in) return;
+
+    for (i = 0; i < count; i++)
+    {
+        convert_VkHostAddressRangeEXT_host_to_win32(&in[i], &out[i]);
+    }
+}
+
 static void convert_VkImageCaptureDescriptorDataInfoEXT_win32_to_host(const VkImageCaptureDescriptorDataInfoEXT32 *in, VkImageCaptureDescriptorDataInfoEXT *out)
 {
     if (!in) return;
@@ -30835,6 +32115,18 @@ static void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceDescriptorHeapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorHeapFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->descriptorHeap = in_ext->descriptorHeap;
+            out_ext->descriptorHeapCaptureReplay = in_ext->descriptorHeapCaptureReplay;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
         {
             VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -31386,6 +32678,17 @@ static void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR:
+        {
+            VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32 *in_ext = (const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR;
+            out_ext->pNext = NULL;
+            out_ext->internallySynchronizedQueues = in_ext->internallySynchronizedQueues;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
         {
             VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -31969,6 +33272,17 @@ static void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV:
+        {
+            VkPhysicalDevicePushConstantBankFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePushConstantBankFeaturesNV32 *in_ext = (const VkPhysicalDevicePushConstantBankFeaturesNV32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV;
+            out_ext->pNext = NULL;
+            out_ext->pushConstantBank = in_ext->pushConstantBank;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
         {
             VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -32550,6 +33864,17 @@ static void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT:
+        {
+            VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->shaderSubgroupPartitioned = in_ext->shaderSubgroupPartitioned;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
         {
             VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -33603,6 +34928,16 @@ static void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDevi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT);
+            const VkPhysicalDeviceDescriptorHeapFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorHeapFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT;
+            out_ext->descriptorHeap = in_ext->descriptorHeap;
+            out_ext->descriptorHeapCaptureReplay = in_ext->descriptorHeapCaptureReplay;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
         {
             VkPhysicalDeviceDescriptorIndexingFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES);
@@ -34066,6 +35401,15 @@ static void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDevi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR:
+        {
+            VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR);
+            const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *in_ext = (const VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR;
+            out_ext->internallySynchronizedQueues = in_ext->internallySynchronizedQueues;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
         {
             VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI);
@@ -34547,6 +35891,15 @@ static void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDevi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV:
+        {
+            VkPhysicalDevicePushConstantBankFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV);
+            const VkPhysicalDevicePushConstantBankFeaturesNV *in_ext = (const VkPhysicalDevicePushConstantBankFeaturesNV *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV;
+            out_ext->pushConstantBank = in_ext->pushConstantBank;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
         {
             VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT);
@@ -35030,6 +36383,15 @@ static void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDevi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT:
+        {
+            VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT);
+            const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT;
+            out_ext->shaderSubgroupPartitioned = in_ext->shaderSubgroupPartitioned;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
         {
             VkPhysicalDeviceShaderSubgroupRotateFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES);
@@ -35984,6 +37346,17 @@ static void convert_VkImageFormatProperties2_win32_to_host(struct conversion_con
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT:
+        {
+            VkSubsampledImageFormatPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSubsampledImageFormatPropertiesEXT32 *in_ext = (const VkSubsampledImageFormatPropertiesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->subsampledImageDescriptorCount = in_ext->subsampledImageDescriptorCount;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
         {
             VkTextureLODGatherFormatPropertiesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -36061,6 +37434,15 @@ static void convert_VkImageFormatProperties2_host_to_win32(const VkImageFormatPr
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT:
+        {
+            VkSubsampledImageFormatPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT);
+            const VkSubsampledImageFormatPropertiesEXT *in_ext = (const VkSubsampledImageFormatPropertiesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT;
+            out_ext->subsampledImageDescriptorCount = in_ext->subsampledImageDescriptorCount;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
         {
             VkTextureLODGatherFormatPropertiesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD);
@@ -36553,6 +37935,24 @@ static void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conversion_
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT;
+            out_ext->pNext = NULL;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM:
+        {
+            VkPhysicalDeviceDescriptorHeapTensorPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM;
+            out_ext->pNext = NULL;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
         {
             VkPhysicalDeviceDescriptorIndexingProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -37022,6 +38422,15 @@ static void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conversion_
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV:
+        {
+            VkPhysicalDevicePushConstantBankPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV;
+            out_ext->pNext = NULL;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
         {
             VkPhysicalDevicePushDescriptorProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -37607,6 +39016,44 @@ static void convert_VkPhysicalDeviceProperties2_host_to_win32(const VkPhysicalDe
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT:
+        {
+            VkPhysicalDeviceDescriptorHeapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT);
+            const VkPhysicalDeviceDescriptorHeapPropertiesEXT *in_ext = (const VkPhysicalDeviceDescriptorHeapPropertiesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT;
+            out_ext->samplerHeapAlignment = in_ext->samplerHeapAlignment;
+            out_ext->resourceHeapAlignment = in_ext->resourceHeapAlignment;
+            out_ext->maxSamplerHeapSize = in_ext->maxSamplerHeapSize;
+            out_ext->maxResourceHeapSize = in_ext->maxResourceHeapSize;
+            out_ext->minSamplerHeapReservedRange = in_ext->minSamplerHeapReservedRange;
+            out_ext->minSamplerHeapReservedRangeWithEmbedded = in_ext->minSamplerHeapReservedRangeWithEmbedded;
+            out_ext->minResourceHeapReservedRange = in_ext->minResourceHeapReservedRange;
+            out_ext->samplerDescriptorSize = in_ext->samplerDescriptorSize;
+            out_ext->imageDescriptorSize = in_ext->imageDescriptorSize;
+            out_ext->bufferDescriptorSize = in_ext->bufferDescriptorSize;
+            out_ext->samplerDescriptorAlignment = in_ext->samplerDescriptorAlignment;
+            out_ext->imageDescriptorAlignment = in_ext->imageDescriptorAlignment;
+            out_ext->bufferDescriptorAlignment = in_ext->bufferDescriptorAlignment;
+            out_ext->maxPushDataSize = in_ext->maxPushDataSize;
+            out_ext->imageCaptureReplayOpaqueDataSize = in_ext->imageCaptureReplayOpaqueDataSize;
+            out_ext->maxDescriptorHeapEmbeddedSamplers = in_ext->maxDescriptorHeapEmbeddedSamplers;
+            out_ext->samplerYcbcrConversionCount = in_ext->samplerYcbcrConversionCount;
+            out_ext->sparseDescriptorHeaps = in_ext->sparseDescriptorHeaps;
+            out_ext->protectedDescriptorHeaps = in_ext->protectedDescriptorHeaps;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM:
+        {
+            VkPhysicalDeviceDescriptorHeapTensorPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM);
+            const VkPhysicalDeviceDescriptorHeapTensorPropertiesARM *in_ext = (const VkPhysicalDeviceDescriptorHeapTensorPropertiesARM *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM;
+            out_ext->tensorDescriptorSize = in_ext->tensorDescriptorSize;
+            out_ext->tensorDescriptorAlignment = in_ext->tensorDescriptorAlignment;
+            out_ext->tensorCaptureReplayOpaqueDataSize = in_ext->tensorCaptureReplayOpaqueDataSize;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
         {
             VkPhysicalDeviceDescriptorIndexingProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES);
@@ -38252,6 +39699,18 @@ static void convert_VkPhysicalDeviceProperties2_host_to_win32(const VkPhysicalDe
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV:
+        {
+            VkPhysicalDevicePushConstantBankPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV);
+            const VkPhysicalDevicePushConstantBankPropertiesNV *in_ext = (const VkPhysicalDevicePushConstantBankPropertiesNV *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV;
+            out_ext->maxGraphicsPushConstantBanks = in_ext->maxGraphicsPushConstantBanks;
+            out_ext->maxComputePushConstantBanks = in_ext->maxComputePushConstantBanks;
+            out_ext->maxGraphicsPushDataBanks = in_ext->maxGraphicsPushDataBanks;
+            out_ext->maxComputePushDataBanks = in_ext->maxComputePushDataBanks;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
         {
             VkPhysicalDevicePushDescriptorProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES);
@@ -42415,6 +43874,18 @@ static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_unwrapped_host(
     return out;
 }
 
+static void convert_VkSamplerCustomBorderColorCreateInfoEXT_win32_to_host(const VkSamplerCustomBorderColorCreateInfoEXT32 *in, VkSamplerCustomBorderColorCreateInfoEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->customBorderColor = in->customBorderColor;
+    out->format = in->format;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
 static void convert_VkReleaseCapturedPipelineDataInfoKHR_win32_to_host(const VkReleaseCapturedPipelineDataInfoKHR32 *in, VkReleaseCapturedPipelineDataInfoKHR *out)
 {
     if (!in) return;
@@ -43008,6 +44479,232 @@ static void convert_VkSemaphoreWaitInfo_win32_to_host(struct conversion_context
         FIXME("Unexpected pNext\n");
 }
 
+#ifdef _WIN64
+static void convert_VkResourceDescriptorInfoEXT_win64_to_host(struct conversion_context *ctx, const VkResourceDescriptorInfoEXT *in, VkResourceDescriptorInfoEXT *out)
+{
+    const VkBaseInStructure *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->type = in->type;
+    out->data = in->data;
+
+    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
+        {
+            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDebugUtilsObjectNameInfoEXT *in_ext = (const VkDebugUtilsObjectNameInfoEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->objectType = in_ext->objectType;
+            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
+            out_ext->pObjectName = in_ext->pObjectName;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static const VkResourceDescriptorInfoEXT *convert_VkResourceDescriptorInfoEXT_array_win64_to_host(struct conversion_context *ctx, const VkResourceDescriptorInfoEXT *in, uint32_t count)
+{
+    VkResourceDescriptorInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkResourceDescriptorInfoEXT_win64_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+#endif /* _WIN64 */
+
+static const VkImageViewCreateInfo *convert_VkImageViewCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkImageViewCreateInfo32 *in, uint32_t count)
+{
+    VkImageViewCreateInfo *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkImageViewCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static void convert_VkImageDescriptorInfoEXT_win32_to_host(struct conversion_context *ctx, const VkImageDescriptorInfoEXT32 *in, VkImageDescriptorInfoEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->pView = convert_VkImageViewCreateInfo_array_win32_to_host(ctx, (const VkImageViewCreateInfo32 *)UlongToPtr(in->pView), 1);
+    out->layout = in->layout;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static const VkImageDescriptorInfoEXT *convert_VkImageDescriptorInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkImageDescriptorInfoEXT32 *in, uint32_t count)
+{
+    VkImageDescriptorInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkImageDescriptorInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static void convert_VkTexelBufferDescriptorInfoEXT_win32_to_host(const VkTexelBufferDescriptorInfoEXT32 *in, VkTexelBufferDescriptorInfoEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->format = in->format;
+    convert_VkDeviceAddressRangeEXT_win32_to_host(&in->addressRange, &out->addressRange);
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static const VkTexelBufferDescriptorInfoEXT *convert_VkTexelBufferDescriptorInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkTexelBufferDescriptorInfoEXT32 *in, uint32_t count)
+{
+    VkTexelBufferDescriptorInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkTexelBufferDescriptorInfoEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static const VkDeviceAddressRangeEXT *convert_VkDeviceAddressRangeEXT_array_win32_to_host(struct conversion_context *ctx, const VkDeviceAddressRangeEXT32 *in, uint32_t count)
+{
+    VkDeviceAddressRangeEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDeviceAddressRangeEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static const VkTensorViewCreateInfoARM *convert_VkTensorViewCreateInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkTensorViewCreateInfoARM32 *in, uint32_t count)
+{
+    VkTensorViewCreateInfoARM *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkTensorViewCreateInfoARM_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
+static void convert_VkResourceDescriptorDataEXT_win32_to_host(struct conversion_context *ctx, const VkResourceDescriptorDataEXT32 *in, VkResourceDescriptorDataEXT *out, VkFlags selector)
+{
+    if (!in) return;
+
+    if (selector == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE || selector == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE || selector == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT || selector == VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM || selector == VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM)
+        out->pImage = convert_VkImageDescriptorInfoEXT_array_win32_to_host(ctx, (const VkImageDescriptorInfoEXT32 *)UlongToPtr(in->pImage), 1);
+    if (selector == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER || selector == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
+        out->pTexelBuffer = convert_VkTexelBufferDescriptorInfoEXT_array_win32_to_host(ctx, (const VkTexelBufferDescriptorInfoEXT32 *)UlongToPtr(in->pTexelBuffer), 1);
+    if (selector == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR || selector == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER || selector == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
+        out->pAddressRange = convert_VkDeviceAddressRangeEXT_array_win32_to_host(ctx, (const VkDeviceAddressRangeEXT32 *)UlongToPtr(in->pAddressRange), 1);
+    if (selector == VK_DESCRIPTOR_TYPE_TENSOR_ARM)
+        out->pTensorARM = convert_VkTensorViewCreateInfoARM_array_win32_to_host(ctx, (const VkTensorViewCreateInfoARM32 *)UlongToPtr(in->pTensorARM), 1);
+}
+
+static void convert_VkResourceDescriptorInfoEXT_win32_to_host(struct conversion_context *ctx, const VkResourceDescriptorInfoEXT32 *in, VkResourceDescriptorInfoEXT *out)
+{
+    const VkBaseInStructure32 *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->type = in->type;
+    convert_VkResourceDescriptorDataEXT_win32_to_host(ctx, &in->data, &out->data, in->type);
+
+    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
+        {
+            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDebugUtilsObjectNameInfoEXT32 *in_ext = (const VkDebugUtilsObjectNameInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->objectType = in_ext->objectType;
+            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
+            out_ext->pObjectName = UlongToPtr(in_ext->pObjectName);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            FIXME("Unhandled sType %u.\n", in_header->sType);
+            break;
+        }
+    }
+}
+
+static const VkResourceDescriptorInfoEXT *convert_VkResourceDescriptorInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkResourceDescriptorInfoEXT32 *in, uint32_t count)
+{
+    VkResourceDescriptorInfoEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkResourceDescriptorInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
+    }
+
+    return out;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkAcquireNextImage2KHR(void *args)
 {
@@ -44412,6 +46109,50 @@ static void thunk32_vkCmdBindPipelineShaderGroupNV(void *args)
     vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
 }
 
+#ifdef _WIN64
+static void thunk64_vkCmdBindResourceHeapEXT(void *args)
+{
+    struct vkCmdBindResourceHeapEXT_params *params = args;
+
+    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindResourceHeapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindInfo);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkCmdBindResourceHeapEXT(void *args)
+{
+    struct
+    {
+        PTR32 commandBuffer;
+        PTR32 pBindInfo;
+    } *params = args;
+    VkBindHeapInfoEXT pBindInfo_host;
+
+    convert_VkBindHeapInfoEXT_win32_to_host((const VkBindHeapInfoEXT32 *)UlongToPtr(params->pBindInfo), &pBindInfo_host);
+    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindResourceHeapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindInfo_host);
+}
+
+#ifdef _WIN64
+static void thunk64_vkCmdBindSamplerHeapEXT(void *args)
+{
+    struct vkCmdBindSamplerHeapEXT_params *params = args;
+
+    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindSamplerHeapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindInfo);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkCmdBindSamplerHeapEXT(void *args)
+{
+    struct
+    {
+        PTR32 commandBuffer;
+        PTR32 pBindInfo;
+    } *params = args;
+    VkBindHeapInfoEXT pBindInfo_host;
+
+    convert_VkBindHeapInfoEXT_win32_to_host((const VkBindHeapInfoEXT32 *)UlongToPtr(params->pBindInfo), &pBindInfo_host);
+    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindSamplerHeapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindInfo_host);
+}
+
 #ifdef _WIN64
 static void thunk64_vkCmdBindShadersEXT(void *args)
 {
@@ -47238,6 +48979,32 @@ static void thunk32_vkCmdPushConstants2KHR(void *args)
     free_conversion_context(ctx);
 }
 
+#ifdef _WIN64
+static void thunk64_vkCmdPushDataEXT(void *args)
+{
+    struct vkCmdPushDataEXT_params *params = args;
+
+    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDataEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDataInfo);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkCmdPushDataEXT(void *args)
+{
+    struct
+    {
+        PTR32 commandBuffer;
+        PTR32 pPushDataInfo;
+    } *params = args;
+    VkPushDataInfoEXT pPushDataInfo_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    init_conversion_context(ctx);
+    convert_VkPushDataInfoEXT_win32_to_host(ctx, (const VkPushDataInfoEXT32 *)UlongToPtr(params->pPushDataInfo), &pPushDataInfo_host);
+    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDataEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDataInfo_host);
+    free_conversion_context(ctx);
+}
+
 #ifdef _WIN64
 static void thunk64_vkCmdPushDescriptorSet(void *args)
 {
@@ -52256,10 +54023,16 @@ static NTSTATUS thunk32_vkCreateRenderPass2KHR(void *args)
 static NTSTATUS thunk64_vkCreateSampler(void *args)
 {
     struct vkCreateSampler_params *params = args;
+    VkSamplerCreateInfo pCreateInfo_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSampler);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSampler(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSampler);
+    init_conversion_context(ctx);
+    convert_VkSamplerCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSampler(vulkan_device_from_handle(params->device)->host.device, &pCreateInfo_host, NULL, params->pSampler);
+    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52437,10 +54210,16 @@ static NTSTATUS thunk32_vkCreateShaderModule(void *args)
 static NTSTATUS thunk64_vkCreateShadersEXT(void *args)
 {
     struct vkCreateShadersEXT_params *params = args;
+    const VkShaderCreateInfoEXT *pCreateInfos_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %u, %p, %p, %p\n", params->device, params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pShaders);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkCreateShadersEXT(vulkan_device_from_handle(params->device)->host.device, params->createInfoCount, params->pCreateInfos, NULL, params->pShaders);
+    init_conversion_context(ctx);
+    pCreateInfos_host = convert_VkShaderCreateInfoEXT_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
+    params->result = vulkan_device_from_handle(params->device)->p_vkCreateShadersEXT(vulkan_device_from_handle(params->device)->host.device, params->createInfoCount, pCreateInfos_host, NULL, params->pShaders);
+    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55680,6 +57459,34 @@ static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetDeviceCombinedImageSamplerIndexNVX(void *args)
+{
+    struct vkGetDeviceCombinedImageSamplerIndexNVX_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->imageViewIndex), wine_dbgstr_longlong(params->samplerIndex));
+
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceCombinedImageSamplerIndexNVX(vulkan_device_from_handle(params->device)->host.device, params->imageViewIndex, params->samplerIndex);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetDeviceCombinedImageSamplerIndexNVX(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint64_t DECLSPEC_ALIGN(8) imageViewIndex;
+        uint64_t DECLSPEC_ALIGN(8) samplerIndex;
+        uint64_t result;
+    } *params = args;
+
+    TRACE("%#x, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->imageViewIndex), wine_dbgstr_longlong(params->samplerIndex));
+
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceCombinedImageSamplerIndexNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->imageViewIndex, params->samplerIndex);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetDeviceFaultInfoEXT(void *args)
 {
@@ -56716,6 +58523,42 @@ static NTSTATUS thunk32_vkGetImageMemoryRequirements2KHR(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetImageOpaqueCaptureDataEXT(void *args)
+{
+    struct vkGetImageOpaqueCaptureDataEXT_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->device, params->imageCount, params->pImages, params->pDatas);
+
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageOpaqueCaptureDataEXT(vulkan_device_from_handle(params->device)->host.device, params->imageCount, params->pImages, params->pDatas);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetImageOpaqueCaptureDataEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t imageCount;
+        PTR32 pImages;
+        PTR32 pDatas;
+        VkResult result;
+    } *params = args;
+    VkHostAddressRangeEXT *pDatas_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    TRACE("%#x, %u, %#x, %#x\n", params->device, params->imageCount, params->pImages, params->pDatas);
+
+    init_conversion_context(ctx);
+    pDatas_host = convert_VkHostAddressRangeEXT_array_win32_to_host(ctx, (VkHostAddressRangeEXT32 *)UlongToPtr(params->pDatas), params->imageCount);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageOpaqueCaptureDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->imageCount, (const VkImage *)UlongToPtr(params->pImages), pDatas_host);
+    convert_VkHostAddressRangeEXT_array_host_to_win32(pDatas_host, (VkHostAddressRangeEXT32 *)UlongToPtr(params->pDatas), params->imageCount);
+    free_conversion_context(ctx);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT(void *args)
 {
@@ -57547,6 +59390,33 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(void *a
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetPhysicalDeviceDescriptorSizeEXT(void *args)
+{
+    struct vkGetPhysicalDeviceDescriptorSizeEXT_params *params = args;
+
+    TRACE("%p, %#x\n", params->physicalDevice, params->descriptorType);
+
+    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceDescriptorSizeEXT(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->descriptorType);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetPhysicalDeviceDescriptorSizeEXT(void *args)
+{
+    struct
+    {
+        PTR32 physicalDevice;
+        VkDescriptorType descriptorType;
+        VkDeviceSize result;
+    } *params = args;
+
+    TRACE("%#x, %#x\n", params->physicalDevice, params->descriptorType);
+
+    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceDescriptorSizeEXT(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->descriptorType);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferProperties(void *args)
 {
@@ -60171,6 +62041,42 @@ static NTSTATUS thunk32_vkGetTensorMemoryRequirementsARM(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetTensorOpaqueCaptureDataARM(void *args)
+{
+    struct vkGetTensorOpaqueCaptureDataARM_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->device, params->tensorCount, params->pTensors, params->pDatas);
+
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetTensorOpaqueCaptureDataARM(vulkan_device_from_handle(params->device)->host.device, params->tensorCount, params->pTensors, params->pDatas);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetTensorOpaqueCaptureDataARM(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t tensorCount;
+        PTR32 pTensors;
+        PTR32 pDatas;
+        VkResult result;
+    } *params = args;
+    VkHostAddressRangeEXT *pDatas_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    TRACE("%#x, %u, %#x, %#x\n", params->device, params->tensorCount, params->pTensors, params->pDatas);
+
+    init_conversion_context(ctx);
+    pDatas_host = convert_VkHostAddressRangeEXT_array_win32_to_host(ctx, (VkHostAddressRangeEXT32 *)UlongToPtr(params->pDatas), params->tensorCount);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetTensorOpaqueCaptureDataARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->tensorCount, (const VkTensorARM *)UlongToPtr(params->pTensors), pDatas_host);
+    convert_VkHostAddressRangeEXT_array_host_to_win32(pDatas_host, (VkHostAddressRangeEXT32 *)UlongToPtr(params->pDatas), params->tensorCount);
+    free_conversion_context(ctx);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetTensorOpaqueCaptureDescriptorDataARM(void *args)
 {
@@ -60983,6 +62889,37 @@ static NTSTATUS thunk32_vkQueueWaitIdle(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkRegisterCustomBorderColorEXT(void *args)
+{
+    struct vkRegisterCustomBorderColorEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p\n", params->device, params->pBorderColor, params->requestIndex, params->pIndex);
+
+    params->result = vulkan_device_from_handle(params->device)->p_vkRegisterCustomBorderColorEXT(vulkan_device_from_handle(params->device)->host.device, params->pBorderColor, params->requestIndex, params->pIndex);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkRegisterCustomBorderColorEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        PTR32 pBorderColor;
+        VkBool32 requestIndex;
+        PTR32 pIndex;
+        VkResult result;
+    } *params = args;
+    VkSamplerCustomBorderColorCreateInfoEXT pBorderColor_host;
+
+    TRACE("%#x, %#x, %u, %#x\n", params->device, params->pBorderColor, params->requestIndex, params->pIndex);
+
+    convert_VkSamplerCustomBorderColorCreateInfoEXT_win32_to_host((const VkSamplerCustomBorderColorCreateInfoEXT32 *)UlongToPtr(params->pBorderColor), &pBorderColor_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkRegisterCustomBorderColorEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pBorderColor_host, params->requestIndex, (uint32_t *)UlongToPtr(params->pIndex));
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkReleaseCapturedPipelineDataKHR(void *args)
 {
@@ -61945,6 +63882,32 @@ static NTSTATUS thunk32_vkUnmapMemory2KHR(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkUnregisterCustomBorderColorEXT(void *args)
+{
+    struct vkUnregisterCustomBorderColorEXT_params *params = args;
+
+    TRACE("%p, %u\n", params->device, params->index);
+
+    vulkan_device_from_handle(params->device)->p_vkUnregisterCustomBorderColorEXT(vulkan_device_from_handle(params->device)->host.device, params->index);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkUnregisterCustomBorderColorEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t index;
+    } *params = args;
+
+    TRACE("%#x, %u\n", params->device, params->index);
+
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUnregisterCustomBorderColorEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->index);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static void thunk64_vkUpdateDescriptorSetWithTemplate(void *args)
 {
@@ -62373,6 +64336,80 @@ static NTSTATUS thunk32_vkWriteMicromapsPropertiesEXT(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static void thunk64_vkWriteResourceDescriptorsEXT(void *args)
+{
+    struct vkWriteResourceDescriptorsEXT_params *params = args;
+    const VkResourceDescriptorInfoEXT *pResources_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    init_conversion_context(ctx);
+    pResources_host = convert_VkResourceDescriptorInfoEXT_array_win64_to_host(ctx, params->pResources, params->resourceCount);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWriteResourceDescriptorsEXT(vulkan_device_from_handle(params->device)->host.device, params->resourceCount, pResources_host, params->pDescriptors);
+    free_conversion_context(ctx);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkWriteResourceDescriptorsEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t resourceCount;
+        PTR32 pResources;
+        PTR32 pDescriptors;
+        VkResult result;
+    } *params = args;
+    const VkResourceDescriptorInfoEXT *pResources_host;
+    const VkHostAddressRangeEXT *pDescriptors_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    init_conversion_context(ctx);
+    pResources_host = convert_VkResourceDescriptorInfoEXT_array_win32_to_host(ctx, (const VkResourceDescriptorInfoEXT32 *)UlongToPtr(params->pResources), params->resourceCount);
+    pDescriptors_host = convert_VkHostAddressRangeEXT_array_win32_to_host(ctx, (const VkHostAddressRangeEXT32 *)UlongToPtr(params->pDescriptors), params->resourceCount);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWriteResourceDescriptorsEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->resourceCount, pResources_host, pDescriptors_host);
+    free_conversion_context(ctx);
+}
+
+#ifdef _WIN64
+static void thunk64_vkWriteSamplerDescriptorsEXT(void *args)
+{
+    struct vkWriteSamplerDescriptorsEXT_params *params = args;
+    const VkSamplerCreateInfo *pSamplers_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    init_conversion_context(ctx);
+    pSamplers_host = convert_VkSamplerCreateInfo_array_win64_to_host(ctx, params->pSamplers, params->samplerCount);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWriteSamplerDescriptorsEXT(vulkan_device_from_handle(params->device)->host.device, params->samplerCount, pSamplers_host, params->pDescriptors);
+    free_conversion_context(ctx);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkWriteSamplerDescriptorsEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t samplerCount;
+        PTR32 pSamplers;
+        PTR32 pDescriptors;
+        VkResult result;
+    } *params = args;
+    const VkSamplerCreateInfo *pSamplers_host;
+    const VkHostAddressRangeEXT *pDescriptors_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    init_conversion_context(ctx);
+    pSamplers_host = convert_VkSamplerCreateInfo_array_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(params->pSamplers), params->samplerCount);
+    pDescriptors_host = convert_VkHostAddressRangeEXT_array_win32_to_host(ctx, (const VkHostAddressRangeEXT32 *)UlongToPtr(params->pDescriptors), params->samplerCount);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWriteSamplerDescriptorsEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->samplerCount, pSamplers_host, pDescriptors_host);
+    free_conversion_context(ctx);
+}
+
 BOOL wine_vk_is_type_wrapped(VkObjectType type)
 {
     return FALSE ||
@@ -62446,6 +64483,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk64_vkCmdBindInvocationMaskHUAWEI,
     (void *)thunk64_vkCmdBindPipeline,
     (void *)thunk64_vkCmdBindPipelineShaderGroupNV,
+    (void *)thunk64_vkCmdBindResourceHeapEXT,
+    (void *)thunk64_vkCmdBindSamplerHeapEXT,
     (void *)thunk64_vkCmdBindShadersEXT,
     (void *)thunk64_vkCmdBindShadingRateImageNV,
     (void *)thunk64_vkCmdBindTileMemoryQCOM,
@@ -62560,6 +64599,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk64_vkCmdPushConstants,
     (void *)thunk64_vkCmdPushConstants2,
     (void *)thunk64_vkCmdPushConstants2KHR,
+    (void *)thunk64_vkCmdPushDataEXT,
     (void *)thunk64_vkCmdPushDescriptorSet,
     (void *)thunk64_vkCmdPushDescriptorSet2,
     (void *)thunk64_vkCmdPushDescriptorSet2KHR,
@@ -62867,6 +64907,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetDeviceAccelerationStructureCompatibilityKHR,
     thunk64_vkGetDeviceBufferMemoryRequirements,
     thunk64_vkGetDeviceBufferMemoryRequirementsKHR,
+    thunk64_vkGetDeviceCombinedImageSamplerIndexNVX,
     thunk64_vkGetDeviceFaultInfoEXT,
     thunk64_vkGetDeviceGroupPeerMemoryFeatures,
     thunk64_vkGetDeviceGroupPeerMemoryFeaturesKHR,
@@ -62897,6 +64938,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetImageMemoryRequirements,
     thunk64_vkGetImageMemoryRequirements2,
     thunk64_vkGetImageMemoryRequirements2KHR,
+    thunk64_vkGetImageOpaqueCaptureDataEXT,
     thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT,
     thunk64_vkGetImageSparseMemoryRequirements,
     thunk64_vkGetImageSparseMemoryRequirements2,
@@ -62922,6 +64964,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
     thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
     thunk64_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
+    thunk64_vkGetPhysicalDeviceDescriptorSizeEXT,
     thunk64_vkGetPhysicalDeviceExternalBufferProperties,
     thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
     thunk64_vkGetPhysicalDeviceExternalFenceProperties,
@@ -63001,6 +65044,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetShaderModuleIdentifierEXT,
     thunk64_vkGetSwapchainImagesKHR,
     thunk64_vkGetTensorMemoryRequirementsARM,
+    thunk64_vkGetTensorOpaqueCaptureDataARM,
     thunk64_vkGetTensorOpaqueCaptureDescriptorDataARM,
     thunk64_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk64_vkGetValidationCacheDataEXT,
@@ -63026,6 +65070,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkQueueSubmit2,
     thunk64_vkQueueSubmit2KHR,
     thunk64_vkQueueWaitIdle,
+    thunk64_vkRegisterCustomBorderColorEXT,
     thunk64_vkReleaseCapturedPipelineDataKHR,
     thunk64_vkReleasePerformanceConfigurationINTEL,
     thunk64_vkReleaseProfilingLockKHR,
@@ -63058,6 +65103,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkUnmapMemory,
     thunk64_vkUnmapMemory2,
     thunk64_vkUnmapMemory2KHR,
+    thunk64_vkUnregisterCustomBorderColorEXT,
     (void *)thunk64_vkUpdateDescriptorSetWithTemplate,
     thunk64_vkUpdateDescriptorSetWithTemplateKHR,
     (void *)thunk64_vkUpdateDescriptorSets,
@@ -63071,6 +65117,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkWaitSemaphoresKHR,
     thunk64_vkWriteAccelerationStructuresPropertiesKHR,
     thunk64_vkWriteMicromapsPropertiesEXT,
+    (void *)thunk64_vkWriteResourceDescriptorsEXT,
+    (void *)thunk64_vkWriteSamplerDescriptorsEXT,
 };
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
 
@@ -63132,6 +65180,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk32_vkCmdBindInvocationMaskHUAWEI,
     (void *)thunk32_vkCmdBindPipeline,
     (void *)thunk32_vkCmdBindPipelineShaderGroupNV,
+    (void *)thunk32_vkCmdBindResourceHeapEXT,
+    (void *)thunk32_vkCmdBindSamplerHeapEXT,
     (void *)thunk32_vkCmdBindShadersEXT,
     (void *)thunk32_vkCmdBindShadingRateImageNV,
     (void *)thunk32_vkCmdBindTileMemoryQCOM,
@@ -63246,6 +65296,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk32_vkCmdPushConstants,
     (void *)thunk32_vkCmdPushConstants2,
     (void *)thunk32_vkCmdPushConstants2KHR,
+    (void *)thunk32_vkCmdPushDataEXT,
     (void *)thunk32_vkCmdPushDescriptorSet,
     (void *)thunk32_vkCmdPushDescriptorSet2,
     (void *)thunk32_vkCmdPushDescriptorSet2KHR,
@@ -63553,6 +65604,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR,
     thunk32_vkGetDeviceBufferMemoryRequirements,
     thunk32_vkGetDeviceBufferMemoryRequirementsKHR,
+    thunk32_vkGetDeviceCombinedImageSamplerIndexNVX,
     thunk32_vkGetDeviceFaultInfoEXT,
     thunk32_vkGetDeviceGroupPeerMemoryFeatures,
     thunk32_vkGetDeviceGroupPeerMemoryFeaturesKHR,
@@ -63583,6 +65635,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetImageMemoryRequirements,
     thunk32_vkGetImageMemoryRequirements2,
     thunk32_vkGetImageMemoryRequirements2KHR,
+    thunk32_vkGetImageOpaqueCaptureDataEXT,
     thunk32_vkGetImageOpaqueCaptureDescriptorDataEXT,
     thunk32_vkGetImageSparseMemoryRequirements,
     thunk32_vkGetImageSparseMemoryRequirements2,
@@ -63608,6 +65661,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
     thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
     thunk32_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
+    thunk32_vkGetPhysicalDeviceDescriptorSizeEXT,
     thunk32_vkGetPhysicalDeviceExternalBufferProperties,
     thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
     thunk32_vkGetPhysicalDeviceExternalFenceProperties,
@@ -63687,6 +65741,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetShaderModuleIdentifierEXT,
     thunk32_vkGetSwapchainImagesKHR,
     thunk32_vkGetTensorMemoryRequirementsARM,
+    thunk32_vkGetTensorOpaqueCaptureDataARM,
     thunk32_vkGetTensorOpaqueCaptureDescriptorDataARM,
     thunk32_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk32_vkGetValidationCacheDataEXT,
@@ -63712,6 +65767,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkQueueSubmit2,
     thunk32_vkQueueSubmit2KHR,
     thunk32_vkQueueWaitIdle,
+    thunk32_vkRegisterCustomBorderColorEXT,
     thunk32_vkReleaseCapturedPipelineDataKHR,
     thunk32_vkReleasePerformanceConfigurationINTEL,
     thunk32_vkReleaseProfilingLockKHR,
@@ -63744,6 +65800,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkUnmapMemory,
     thunk32_vkUnmapMemory2,
     thunk32_vkUnmapMemory2KHR,
+    thunk32_vkUnregisterCustomBorderColorEXT,
     (void *)thunk32_vkUpdateDescriptorSetWithTemplate,
     thunk32_vkUpdateDescriptorSetWithTemplateKHR,
     (void *)thunk32_vkUpdateDescriptorSets,
@@ -63757,5 +65814,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkWaitSemaphoresKHR,
     thunk32_vkWriteAccelerationStructuresPropertiesKHR,
     thunk32_vkWriteMicromapsPropertiesEXT,
+    (void *)thunk32_vkWriteResourceDescriptorsEXT,
+    (void *)thunk32_vkWriteSamplerDescriptorsEXT,
 };
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
diff --git a/dlls/winevulkan/winevulkan.json b/dlls/winevulkan/winevulkan.json
index 23c35331e5a..5e6716289f3 100644
--- a/dlls/winevulkan/winevulkan.json
+++ b/dlls/winevulkan/winevulkan.json
@@ -2,6 +2,6 @@
     "file_format_version": "1.0.0",
     "ICD": {
         "library_path": ".\\winevulkan.dll",
-        "api_version": "1.4.339"
+        "api_version": "1.4.340"
     }
 }
diff --git a/include/wine/vulkan.h b/include/wine/vulkan.h
index 921ff9e467e..8c0d8320b06 100644
--- a/include/wine/vulkan.h
+++ b/include/wine/vulkan.h
@@ -121,7 +121,7 @@ typedef struct _XDisplay Display;
 #define VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME "VK_EXT_transform_feedback"
 #define VK_NVX_BINARY_IMPORT_SPEC_VERSION 2
 #define VK_NVX_BINARY_IMPORT_EXTENSION_NAME "VK_NVX_binary_import"
-#define VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION 3
+#define VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION 4
 #define VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME "VK_NVX_image_view_handle"
 #define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 2
 #define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"
@@ -268,6 +268,8 @@ typedef struct _XDisplay Display;
 #define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"
 #define VK_AMD_GPU_SHADER_INT16_SPEC_VERSION 2
 #define VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME "VK_AMD_gpu_shader_int16"
+#define VK_EXT_DESCRIPTOR_HEAP_SPEC_VERSION 1
+#define VK_EXT_DESCRIPTOR_HEAP_EXTENSION_NAME "VK_EXT_descriptor_heap"
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"
 #define VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION 1
@@ -400,7 +402,7 @@ typedef struct _XDisplay Display;
 #define VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME "VK_KHR_shader_terminate_invocation"
 #define VK_EXT_METAL_SURFACE_SPEC_VERSION 1
 #define VK_EXT_METAL_SURFACE_EXTENSION_NAME "VK_EXT_metal_surface"
-#define VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION 2
+#define VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION 3
 #define VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME "VK_EXT_fragment_density_map"
 #define VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION 1
 #define VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME "VK_EXT_scalar_block_layout"
@@ -729,6 +731,8 @@ typedef struct _XDisplay Display;
 #define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME "VK_EXT_pipeline_library_group_handles"
 #define VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION 1
 #define VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME "VK_EXT_dynamic_rendering_unused_attachments"
+#define VK_KHR_INTERNALLY_SYNCHRONIZED_QUEUES_SPEC_VERSION 1
+#define VK_KHR_INTERNALLY_SYNCHRONIZED_QUEUES_EXTENSION_NAME "VK_KHR_internally_synchronized_queues"
 #define VK_NV_LOW_LATENCY_2_SPEC_VERSION 2
 #define VK_NV_LOW_LATENCY_2_EXTENSION_NAME "VK_NV_low_latency2"
 #define VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION 2
@@ -819,6 +823,8 @@ typedef struct _XDisplay Display;
 #define VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME "VK_MESA_image_alignment_control"
 #define VK_KHR_SHADER_FMA_SPEC_VERSION 1
 #define VK_KHR_SHADER_FMA_EXTENSION_NAME "VK_KHR_shader_fma"
+#define VK_NV_PUSH_CONSTANT_BANK_SPEC_VERSION 1
+#define VK_NV_PUSH_CONSTANT_BANK_EXTENSION_NAME "VK_NV_push_constant_bank"
 #define VK_EXT_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION 1
 #define VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME "VK_EXT_ray_tracing_invocation_reorder"
 #define VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION 1
@@ -867,6 +873,8 @@ typedef struct _XDisplay Display;
 #define VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME "VK_EXT_shader_uniform_buffer_unsized_array"
 #define VK_NV_COMPUTE_OCCUPANCY_PRIORITY_SPEC_VERSION 1
 #define VK_NV_COMPUTE_OCCUPANCY_PRIORITY_EXTENSION_NAME "VK_NV_compute_occupancy_priority"
+#define VK_EXT_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION 1
+#define VK_EXT_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME "VK_EXT_shader_subgroup_partitioned"
 #define STD_VIDEO_H264_CPB_CNT_LIST_SIZE 32
 #define STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS 6
 #define STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS 16
@@ -963,7 +971,7 @@ typedef struct _XDisplay Display;
 #define VK_API_VERSION_1_3 VK_MAKE_API_VERSION(0, 1, 3, 0)
 #define VK_API_VERSION_1_4 VK_MAKE_API_VERSION(0, 1, 4, 0)
 #define VKSC_API_VERSION_1_0 VK_MAKE_API_VERSION(VKSC_API_VARIANT, 1, 0, 0)
-#define VK_HEADER_VERSION 339
+#define VK_HEADER_VERSION 340
 #define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 4, VK_HEADER_VERSION)
 #define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;
 #define VK_USE_64_BIT_PTR_DEFINES 0
@@ -1294,6 +1302,7 @@ typedef VkFlags VkShaderModuleCreateFlags;
 typedef VkFlags VkShaderStageFlags;
 typedef VkFlags VkSparseImageFormatFlags;
 typedef VkFlags VkSparseMemoryBindFlags;
+typedef VkFlags VkSpirvResourceTypeFlagsEXT;
 typedef VkFlags VkStencilFaceFlags;
 typedef VkFlags VkStreamDescriptorSurfaceCreateFlagsGGP;
 typedef VkFlags VkSubgroupFeatureFlags;
@@ -1977,6 +1986,8 @@ static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM = 0x10000000000000ull;
 static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT = 0x80000000000000ull;
 static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT = 0x100000000000000ull;
+static const VkAccessFlagBits2 VK_ACCESS_2_SAMPLER_HEAP_READ_BIT_EXT = 0x200000000000000ull;
+static const VkAccessFlagBits2 VK_ACCESS_2_RESOURCE_HEAP_READ_BIT_EXT = 0x400000000000000ull;
 typedef VkAccessFlagBits2 VkAccessFlagBits2KHR;
 
 typedef VkFlags64 VkAccessFlagBits3KHR;
@@ -2191,6 +2202,7 @@ typedef enum VkBufferUsageFlagBits
     VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
     VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
     VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
+    VK_BUFFER_USAGE_DESCRIPTOR_HEAP_BIT_EXT = 0x10000000,
     VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
     VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
     VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
@@ -2236,6 +2248,7 @@ static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000ull;
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000ull;
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM = 0x08000000ull;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_DESCRIPTOR_HEAP_BIT_EXT = 0x10000000ull;
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM = 0x20000000ull;
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = 0x80000000ull;
 static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT = 0x100000000ull;
@@ -2737,6 +2750,22 @@ typedef enum VkDescriptorBindingFlagBits
 } VkDescriptorBindingFlagBits;
 typedef VkDescriptorBindingFlagBits VkDescriptorBindingFlagBitsEXT;
 
+typedef enum VkDescriptorMappingSourceEXT
+{
+    VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_CONSTANT_OFFSET_EXT = 0,
+    VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_PUSH_INDEX_EXT = 1,
+    VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_EXT = 2,
+    VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_INDIRECT_INDEX_ARRAY_EXT = 3,
+    VK_DESCRIPTOR_MAPPING_SOURCE_RESOURCE_HEAP_DATA_EXT = 4,
+    VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_DATA_EXT = 5,
+    VK_DESCRIPTOR_MAPPING_SOURCE_PUSH_ADDRESS_EXT = 6,
+    VK_DESCRIPTOR_MAPPING_SOURCE_INDIRECT_ADDRESS_EXT = 7,
+    VK_DESCRIPTOR_MAPPING_SOURCE_HEAP_WITH_SHADER_RECORD_INDEX_EXT = 8,
+    VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_DATA_EXT = 9,
+    VK_DESCRIPTOR_MAPPING_SOURCE_SHADER_RECORD_ADDRESS_EXT = 10,
+    VK_DESCRIPTOR_MAPPING_SOURCE_EXT_MAX_ENUM = 0x7fffffff,
+} VkDescriptorMappingSourceEXT;
+
 typedef enum VkDescriptorPoolCreateFlagBits
 {
     VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
@@ -2852,6 +2881,7 @@ typedef enum VkDeviceGroupPresentModeFlagBitsKHR
 typedef enum VkDeviceQueueCreateFlagBits
 {
     VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
+    VK_DEVICE_QUEUE_CREATE_INTERNALLY_SYNCHRONIZED_BIT_KHR = 0x00000004,
     VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
 } VkDeviceQueueCreateFlagBits;
 
@@ -3805,7 +3835,7 @@ typedef enum VkImageCreateFlagBits
     VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
     VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
     VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = 0x00008000,
-    VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
+    VK_IMAGE_CREATE_DESCRIPTOR_HEAP_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
     VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
     VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
     VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
@@ -3816,6 +3846,7 @@ typedef enum VkImageCreateFlagBits
     VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
     VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
     VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
+    VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = VK_IMAGE_CREATE_DESCRIPTOR_HEAP_CAPTURE_REPLAY_BIT_EXT,
     VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT,
 } VkImageCreateFlagBits;
 
@@ -3979,6 +4010,8 @@ typedef enum VkIndirectCommandsTokenTypeEXT
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
+    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT = 1000135000,
+    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT = 1000135001,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
@@ -3997,6 +4030,7 @@ typedef enum VkIndirectCommandsTokenTypeNV
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
+    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV = 1000135000,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
     VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
@@ -4601,6 +4635,7 @@ static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONL
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = 0x80000000ull;
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV = 0x200000000ull;
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ull;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT = 0x1000000000ull;
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM = 0x2000000000ull;
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = 0x4000000000ull;
 static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x10000000000ull;
@@ -5296,6 +5331,7 @@ typedef enum VkShaderCreateFlagBitsEXT
     VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
     VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
     VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = 0x00000080,
+    VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT = 0x00000400,
     VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT = 0x00008000,
     VK_SHADER_CREATE_FLAG_BITS_EXT_MAX_ENUM = 0x7fffffff,
 } VkShaderCreateFlagBitsEXT;
@@ -5397,6 +5433,21 @@ typedef enum VkSparseMemoryBindFlagBits
     VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7fffffff,
 } VkSparseMemoryBindFlagBits;
 
+typedef enum VkSpirvResourceTypeFlagBitsEXT
+{
+    VK_SPIRV_RESOURCE_TYPE_SAMPLER_BIT_EXT = 0x00000001,
+    VK_SPIRV_RESOURCE_TYPE_SAMPLED_IMAGE_BIT_EXT = 0x00000002,
+    VK_SPIRV_RESOURCE_TYPE_READ_ONLY_IMAGE_BIT_EXT = 0x00000004,
+    VK_SPIRV_RESOURCE_TYPE_READ_WRITE_IMAGE_BIT_EXT = 0x00000008,
+    VK_SPIRV_RESOURCE_TYPE_COMBINED_SAMPLED_IMAGE_BIT_EXT = 0x00000010,
+    VK_SPIRV_RESOURCE_TYPE_UNIFORM_BUFFER_BIT_EXT = 0x00000020,
+    VK_SPIRV_RESOURCE_TYPE_READ_ONLY_STORAGE_BUFFER_BIT_EXT = 0x00000040,
+    VK_SPIRV_RESOURCE_TYPE_READ_WRITE_STORAGE_BUFFER_BIT_EXT = 0x00000080,
+    VK_SPIRV_RESOURCE_TYPE_ACCELERATION_STRUCTURE_BIT_EXT = 0x00000100,
+    VK_SPIRV_RESOURCE_TYPE_TENSOR_BIT_ARM = 0x00000200,
+    VK_SPIRV_RESOURCE_TYPE_ALL_EXT = 0x7fffffff,
+} VkSpirvResourceTypeFlagBitsEXT;
+
 typedef enum VkStencilFaceFlagBits
 {
     VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
@@ -5674,6 +5725,21 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
     VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
+    VK_STRUCTURE_TYPE_TEXEL_BUFFER_DESCRIPTOR_INFO_EXT = 1000135000,
+    VK_STRUCTURE_TYPE_IMAGE_DESCRIPTOR_INFO_EXT = 1000135001,
+    VK_STRUCTURE_TYPE_RESOURCE_DESCRIPTOR_INFO_EXT = 1000135002,
+    VK_STRUCTURE_TYPE_BIND_HEAP_INFO_EXT = 1000135003,
+    VK_STRUCTURE_TYPE_PUSH_DATA_INFO_EXT = 1000135004,
+    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_AND_BINDING_MAPPING_EXT = 1000135005,
+    VK_STRUCTURE_TYPE_SHADER_DESCRIPTOR_SET_AND_BINDING_MAPPING_INFO_EXT = 1000135006,
+    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DATA_CREATE_INFO_EXT = 1000135007,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_PROPERTIES_EXT = 1000135008,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_FEATURES_EXT = 1000135009,
+    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_DESCRIPTOR_HEAP_INFO_EXT = 1000135010,
+    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_INDEX_CREATE_INFO_EXT = 1000135011,
+    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_PUSH_DATA_TOKEN_NV = 1000135012,
+    VK_STRUCTURE_TYPE_SUBSAMPLED_IMAGE_FORMAT_PROPERTIES_EXT = 1000135013,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_HEAP_TENSOR_PROPERTIES_ARM = 1000135014,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
     VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
@@ -6212,6 +6278,7 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INTERNALLY_SYNCHRONIZED_QUEUES_FEATURES_KHR = 1000504000,
     VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
     VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
     VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
@@ -6366,6 +6433,9 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
     VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR = 1000579000,
+    VK_STRUCTURE_TYPE_PUSH_CONSTANT_BANK_INFO_NV = 1000580000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_FEATURES_NV = 1000580001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_CONSTANT_BANK_PROPERTIES_NV = 1000580002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT = 1000581000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT = 1000581001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
@@ -6410,6 +6480,7 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT = 1000642000,
     VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV = 1000645000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV = 1000645001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_PARTITIONED_FEATURES_EXT = 1000662000,
     VK_STRUCTURE_TYPE_MAX_ENUM = 0x7fffffff,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
@@ -6674,10 +6745,11 @@ typedef enum VkSubgroupFeatureFlagBits
     VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
     VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
     VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
-    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
+    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_EXT = 0x00000100,
     VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
     VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
     VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_EXT,
     VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_BIT,
     VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
 } VkSubgroupFeatureFlagBits;
@@ -6776,6 +6848,7 @@ typedef VkFlags64 VkTensorCreateFlagBitsARM;
 static const VkTensorCreateFlagBitsARM VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM = 0x00000001ull;
 static const VkTensorCreateFlagBitsARM VK_TENSOR_CREATE_PROTECTED_BIT_ARM = 0x00000002ull;
 static const VkTensorCreateFlagBitsARM VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = 0x00000004ull;
+static const VkTensorCreateFlagBitsARM VK_TENSOR_CREATE_DESCRIPTOR_HEAP_CAPTURE_REPLAY_BIT_ARM = 0x00000008ull;
 
 typedef enum VkTensorTilingARM
 {
@@ -7333,6 +7406,14 @@ typedef struct StdVideoH265SpsVuiFlags
     uint32_t restricted_ref_pic_lists_flag:1;
 } StdVideoH265SpsVuiFlags;
 
+typedef struct VkComponentMapping
+{
+    VkComponentSwizzle r;
+    VkComponentSwizzle g;
+    VkComponentSwizzle b;
+    VkComponentSwizzle a;
+} VkComponentMapping;
+
 typedef union VkDeviceOrHostAddressConstKHR
 {
     VkDeviceAddress WINE_VK_ALIGN(8) deviceAddress;
@@ -7366,6 +7447,15 @@ typedef struct VkGeometryTrianglesNV
     VkDeviceSize WINE_VK_ALIGN(8) transformOffset;
 } VkGeometryTrianglesNV;
 
+typedef struct VkImageSubresourceRange
+{
+    VkImageAspectFlags aspectMask;
+    uint32_t baseMipLevel;
+    uint32_t levelCount;
+    uint32_t baseArrayLayer;
+    uint32_t layerCount;
+} VkImageSubresourceRange;
+
 typedef struct VkPushConstantRange
 {
     VkShaderStageFlags stageFlags;
@@ -7373,6 +7463,28 @@ typedef struct VkPushConstantRange
     uint32_t size;
 } VkPushConstantRange;
 
+typedef struct VkSamplerCreateInfo
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSamplerCreateFlags flags;
+    VkFilter magFilter;
+    VkFilter minFilter;
+    VkSamplerMipmapMode mipmapMode;
+    VkSamplerAddressMode addressModeU;
+    VkSamplerAddressMode addressModeV;
+    VkSamplerAddressMode addressModeW;
+    float mipLodBias;
+    VkBool32 anisotropyEnable;
+    float maxAnisotropy;
+    VkBool32 compareEnable;
+    VkCompareOp compareOp;
+    float minLod;
+    float maxLod;
+    VkBorderColor borderColor;
+    VkBool32 unnormalizedCoordinates;
+} VkSamplerCreateInfo;
+
 typedef struct VkSpecializationMapEntry
 {
     uint32_t constantID;
@@ -7823,6 +7935,91 @@ typedef struct VkClusterAccelerationStructureTriangleClusterInputNV
     uint32_t minPositionTruncateBitCount;
 } VkClusterAccelerationStructureTriangleClusterInputNV;
 
+typedef struct VkDescriptorMappingSourceConstantOffsetEXT
+{
+    uint32_t heapOffset;
+    uint32_t heapArrayStride;
+    const VkSamplerCreateInfo *pEmbeddedSampler;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceConstantOffsetEXT;
+
+typedef struct VkDescriptorMappingSourceHeapDataEXT
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+} VkDescriptorMappingSourceHeapDataEXT;
+
+typedef struct VkDescriptorMappingSourceIndirectAddressEXT
+{
+    uint32_t pushOffset;
+    uint32_t addressOffset;
+} VkDescriptorMappingSourceIndirectAddressEXT;
+
+typedef struct VkDescriptorMappingSourceIndirectIndexArrayEXT
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t addressOffset;
+    uint32_t heapIndexStride;
+    const VkSamplerCreateInfo *pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerAddressOffset;
+    uint32_t samplerHeapIndexStride;
+} VkDescriptorMappingSourceIndirectIndexArrayEXT;
+
+typedef struct VkDescriptorMappingSourceIndirectIndexEXT
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t addressOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    const VkSamplerCreateInfo *pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerAddressOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceIndirectIndexEXT;
+
+typedef struct VkDescriptorMappingSourcePushIndexEXT
+{
+    uint32_t heapOffset;
+    uint32_t pushOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    const VkSamplerCreateInfo *pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerPushOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourcePushIndexEXT;
+
+typedef struct VkDescriptorMappingSourceShaderRecordIndexEXT
+{
+    uint32_t heapOffset;
+    uint32_t shaderRecordOffset;
+    uint32_t heapIndexStride;
+    uint32_t heapArrayStride;
+    const VkSamplerCreateInfo *pEmbeddedSampler;
+    VkBool32 useCombinedImageSamplerIndex;
+    uint32_t samplerHeapOffset;
+    uint32_t samplerShaderRecordOffset;
+    uint32_t samplerHeapIndexStride;
+    uint32_t samplerHeapArrayStride;
+} VkDescriptorMappingSourceShaderRecordIndexEXT;
+
+typedef struct VkDeviceAddressRangeEXT
+{
+    VkDeviceAddress WINE_VK_ALIGN(8) address;
+    VkDeviceSize WINE_VK_ALIGN(8) size;
+} VkDeviceAddressRangeEXT;
+
 typedef struct VkExtent2D
 {
     uint32_t width;
@@ -7849,6 +8046,18 @@ typedef struct VkImageSubresource
     uint32_t arrayLayer;
 } VkImageSubresource;
 
+typedef struct VkImageViewCreateInfo
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkImageViewCreateFlags flags;
+    VkImage WINE_VK_ALIGN(8) image;
+    VkImageViewType viewType;
+    VkFormat format;
+    VkComponentMapping components;
+    VkImageSubresourceRange subresourceRange;
+} VkImageViewCreateInfo;
+
 typedef struct VkIndirectCommandsExecutionSetTokenEXT
 {
     VkIndirectExecutionSetInfoTypeEXT type;
@@ -8727,6 +8936,21 @@ typedef struct VkDescriptorImageInfo
     VkImageLayout imageLayout;
 } VkDescriptorImageInfo;
 
+typedef union VkDescriptorMappingSourceDataEXT
+{
+    VkDescriptorMappingSourceConstantOffsetEXT constantOffset;
+    VkDescriptorMappingSourcePushIndexEXT pushIndex;
+    VkDescriptorMappingSourceIndirectIndexEXT indirectIndex;
+    VkDescriptorMappingSourceIndirectIndexArrayEXT indirectIndexArray;
+    VkDescriptorMappingSourceHeapDataEXT heapData;
+    uint32_t pushDataOffset;
+    uint32_t pushAddressOffset;
+    VkDescriptorMappingSourceIndirectAddressEXT indirectAddress;
+    VkDescriptorMappingSourceShaderRecordIndexEXT shaderRecordIndex;
+    uint32_t shaderRecordDataOffset;
+    uint32_t shaderRecordAddressOffset;
+} VkDescriptorMappingSourceDataEXT;
+
 typedef struct VkGeometryNV
 {
     VkStructureType sType;
@@ -8755,6 +8979,14 @@ typedef struct VkImageCreateInfo
     VkImageLayout initialLayout;
 } VkImageCreateInfo;
 
+typedef struct VkImageDescriptorInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    const VkImageViewCreateInfo *pView;
+    VkImageLayout layout;
+} VkImageDescriptorInfoEXT;
+
 typedef struct VkImageSubresourceLayers
 {
     VkImageAspectFlags aspectMask;
@@ -8763,15 +8995,6 @@ typedef struct VkImageSubresourceLayers
     uint32_t layerCount;
 } VkImageSubresourceLayers;
 
-typedef struct VkImageSubresourceRange
-{
-    VkImageAspectFlags aspectMask;
-    uint32_t baseMipLevel;
-    uint32_t levelCount;
-    uint32_t baseArrayLayer;
-    uint32_t layerCount;
-} VkImageSubresourceRange;
-
 typedef union VkIndirectCommandsTokenDataEXT
 {
     const VkIndirectCommandsPushConstantTokenEXT *pPushConstant;
@@ -8953,6 +9176,23 @@ typedef struct VkTensorDescriptionARM
     VkTensorUsageFlagsARM WINE_VK_ALIGN(8) usage;
 } VkTensorDescriptionARM;
 
+typedef struct VkTensorViewCreateInfoARM
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkTensorViewCreateFlagsARM WINE_VK_ALIGN(8) flags;
+    VkTensorARM WINE_VK_ALIGN(8) tensor;
+    VkFormat format;
+} VkTensorViewCreateInfoARM;
+
+typedef struct VkTexelBufferDescriptorInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFormat format;
+    VkDeviceAddressRangeEXT WINE_VK_ALIGN(8) addressRange;
+} VkTexelBufferDescriptorInfoEXT;
+
 typedef struct VkVideoPictureResourceInfoKHR
 {
     VkStructureType sType;
@@ -9282,6 +9522,15 @@ typedef struct VkAttachmentSampleLocationsEXT
     VkSampleLocationsInfoEXT sampleLocationsInfo;
 } VkAttachmentSampleLocationsEXT;
 
+typedef struct VkBindHeapInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDeviceAddressRangeEXT WINE_VK_ALIGN(8) heapRange;
+    VkDeviceSize WINE_VK_ALIGN(8) reservedRangeOffset;
+    VkDeviceSize WINE_VK_ALIGN(8) reservedRangeSize;
+} VkBindHeapInfoEXT;
+
 typedef struct VkBufferCopy2
 {
     VkStructureType sType;
@@ -9380,14 +9629,6 @@ typedef struct VkCommandBufferSubmitInfo
 } VkCommandBufferSubmitInfo;
 typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;
 
-typedef struct VkComponentMapping
-{
-    VkComponentSwizzle r;
-    VkComponentSwizzle g;
-    VkComponentSwizzle b;
-    VkComponentSwizzle a;
-} VkComponentMapping;
-
 typedef struct VkConformanceVersion
 {
     uint8_t major;
@@ -9465,6 +9706,18 @@ typedef struct VkDescriptorPoolSize
     uint32_t descriptorCount;
 } VkDescriptorPoolSize;
 
+typedef struct VkDescriptorSetAndBindingMappingEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t descriptorSet;
+    uint32_t firstBinding;
+    uint32_t bindingCount;
+    VkSpirvResourceTypeFlagsEXT resourceMask;
+    VkDescriptorMappingSourceEXT source;
+    VkDescriptorMappingSourceDataEXT sourceData;
+} VkDescriptorSetAndBindingMappingEXT;
+
 typedef struct VkDescriptorSetLayoutBinding
 {
     uint32_t binding;
@@ -9574,6 +9827,12 @@ typedef struct VkGraphicsShaderGroupCreateInfoNV
     const VkPipelineTessellationStateCreateInfo *pTessellationState;
 } VkGraphicsShaderGroupCreateInfoNV;
 
+typedef struct VkHostAddressRangeConstEXT
+{
+    const void *address;
+    size_t size;
+} VkHostAddressRangeConstEXT;
+
 typedef struct VkImageBlit2
 {
     VkStructureType sType;
@@ -10117,6 +10376,14 @@ typedef struct VkRenderingAttachmentInfo
 } VkRenderingAttachmentInfo;
 typedef VkRenderingAttachmentInfo VkRenderingAttachmentInfoKHR;
 
+typedef union VkResourceDescriptorDataEXT
+{
+    const VkImageDescriptorInfoEXT *pImage;
+    const VkTexelBufferDescriptorInfoEXT *pTexelBuffer;
+    const VkDeviceAddressRangeEXT *pAddressRange;
+    const VkTensorViewCreateInfoARM *pTensorARM;
+} VkResourceDescriptorDataEXT;
+
 typedef struct VkSemaphoreSubmitInfo
 {
     VkStructureType sType;
@@ -11171,6 +11438,14 @@ typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT
     VkBool32 conditionalRenderingEnable;
 } VkCommandBufferInheritanceConditionalRenderingInfoEXT;
 
+typedef struct VkCommandBufferInheritanceDescriptorHeapInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    const VkBindHeapInfoEXT *pSamplerHeapBindInfo;
+    const VkBindHeapInfoEXT *pResourceHeapBindInfo;
+} VkCommandBufferInheritanceDescriptorHeapInfoEXT;
+
 typedef struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM
 {
     VkStructureType sType;
@@ -12671,6 +12946,12 @@ typedef struct VkHeadlessSurfaceCreateInfoEXT
     VkHeadlessSurfaceCreateFlagsEXT flags;
 } VkHeadlessSurfaceCreateInfoEXT;
 
+typedef struct VkHostAddressRangeEXT
+{
+    void *address;
+    size_t size;
+} VkHostAddressRangeEXT;
+
 typedef struct VkHostImageCopyDevicePerformanceQuery
 {
     VkStructureType sType;
@@ -12864,18 +13145,6 @@ typedef struct VkImageViewCaptureDescriptorDataInfoEXT
     VkImageView WINE_VK_ALIGN(8) imageView;
 } VkImageViewCaptureDescriptorDataInfoEXT;
 
-typedef struct VkImageViewCreateInfo
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkImageViewCreateFlags flags;
-    VkImage WINE_VK_ALIGN(8) image;
-    VkImageViewType viewType;
-    VkFormat format;
-    VkComponentMapping components;
-    VkImageSubresourceRange subresourceRange;
-} VkImageViewCreateInfo;
-
 typedef struct VkImageViewHandleInfoNVX
 {
     VkStructureType sType;
@@ -13016,6 +13285,14 @@ typedef struct VkIndirectCommandsLayoutCreateInfoNV
     const uint32_t *pStreamStrides;
 } VkIndirectCommandsLayoutCreateInfoNV;
 
+typedef struct VkIndirectCommandsLayoutPushDataTokenNV
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t pushDataOffset;
+    uint32_t pushDataSize;
+} VkIndirectCommandsLayoutPushDataTokenNV;
+
 typedef struct VkIndirectExecutionSetCreateInfoEXT
 {
     VkStructureType sType;
@@ -13374,6 +13651,13 @@ typedef struct VkMutableDescriptorTypeCreateInfoEXT
 } VkMutableDescriptorTypeCreateInfoEXT;
 typedef VkMutableDescriptorTypeCreateInfoEXT VkMutableDescriptorTypeCreateInfoVALVE;
 
+typedef struct VkOpaqueCaptureDataCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    const VkHostAddressRangeConstEXT *pData;
+} VkOpaqueCaptureDataCreateInfoEXT;
+
 typedef struct VkOpaqueCaptureDescriptorDataCreateInfoEXT
 {
     VkStructureType sType;
@@ -14114,6 +14398,48 @@ typedef struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM
     size_t tensorDescriptorSize;
 } VkPhysicalDeviceDescriptorBufferTensorPropertiesARM;
 
+typedef struct VkPhysicalDeviceDescriptorHeapFeaturesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 descriptorHeap;
+    VkBool32 descriptorHeapCaptureReplay;
+} VkPhysicalDeviceDescriptorHeapFeaturesEXT;
+
+typedef struct VkPhysicalDeviceDescriptorHeapPropertiesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    VkDeviceSize WINE_VK_ALIGN(8) samplerHeapAlignment;
+    VkDeviceSize WINE_VK_ALIGN(8) resourceHeapAlignment;
+    VkDeviceSize WINE_VK_ALIGN(8) maxSamplerHeapSize;
+    VkDeviceSize WINE_VK_ALIGN(8) maxResourceHeapSize;
+    VkDeviceSize WINE_VK_ALIGN(8) minSamplerHeapReservedRange;
+    VkDeviceSize WINE_VK_ALIGN(8) minSamplerHeapReservedRangeWithEmbedded;
+    VkDeviceSize WINE_VK_ALIGN(8) minResourceHeapReservedRange;
+    VkDeviceSize WINE_VK_ALIGN(8) samplerDescriptorSize;
+    VkDeviceSize WINE_VK_ALIGN(8) imageDescriptorSize;
+    VkDeviceSize WINE_VK_ALIGN(8) bufferDescriptorSize;
+    VkDeviceSize WINE_VK_ALIGN(8) samplerDescriptorAlignment;
+    VkDeviceSize WINE_VK_ALIGN(8) imageDescriptorAlignment;
+    VkDeviceSize WINE_VK_ALIGN(8) bufferDescriptorAlignment;
+    VkDeviceSize WINE_VK_ALIGN(8) maxPushDataSize;
+    size_t imageCaptureReplayOpaqueDataSize;
+    uint32_t maxDescriptorHeapEmbeddedSamplers;
+    uint32_t samplerYcbcrConversionCount;
+    VkBool32 sparseDescriptorHeaps;
+    VkBool32 protectedDescriptorHeaps;
+} VkPhysicalDeviceDescriptorHeapPropertiesEXT;
+
+typedef struct VkPhysicalDeviceDescriptorHeapTensorPropertiesARM
+{
+    VkStructureType sType;
+    void *pNext;
+    VkDeviceSize WINE_VK_ALIGN(8) tensorDescriptorSize;
+    VkDeviceSize WINE_VK_ALIGN(8) tensorDescriptorAlignment;
+    size_t tensorCaptureReplayOpaqueDataSize;
+} VkPhysicalDeviceDescriptorHeapTensorPropertiesARM;
+
 typedef struct VkPhysicalDeviceDescriptorIndexingFeatures
 {
     VkStructureType sType;
@@ -14869,6 +15195,13 @@ typedef struct VkPhysicalDeviceInlineUniformBlockProperties
 } VkPhysicalDeviceInlineUniformBlockProperties;
 typedef VkPhysicalDeviceInlineUniformBlockProperties VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
 
+typedef struct VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 internallySynchronizedQueues;
+} VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR;
+
 typedef struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
 {
     VkStructureType sType;
@@ -15592,6 +15925,23 @@ typedef struct VkPhysicalDeviceProvokingVertexPropertiesEXT
     VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
 } VkPhysicalDeviceProvokingVertexPropertiesEXT;
 
+typedef struct VkPhysicalDevicePushConstantBankFeaturesNV
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 pushConstantBank;
+} VkPhysicalDevicePushConstantBankFeaturesNV;
+
+typedef struct VkPhysicalDevicePushConstantBankPropertiesNV
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t maxGraphicsPushConstantBanks;
+    uint32_t maxComputePushConstantBanks;
+    uint32_t maxGraphicsPushDataBanks;
+    uint32_t maxComputePushDataBanks;
+} VkPhysicalDevicePushConstantBankPropertiesNV;
+
 typedef struct VkPhysicalDevicePushDescriptorProperties
 {
     VkStructureType sType;
@@ -16208,6 +16558,13 @@ typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
 } VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
 typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;
 
+typedef struct VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 shaderSubgroupPartitioned;
+} VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT;
+
 typedef struct VkPhysicalDeviceShaderSubgroupRotateFeatures
 {
     VkStructureType sType;
@@ -17457,6 +17814,13 @@ typedef struct VkProtectedSubmitInfo
     VkBool32 protectedSubmit;
 } VkProtectedSubmitInfo;
 
+typedef struct VkPushConstantBankInfoNV
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t bank;
+} VkPushConstantBankInfoNV;
+
 typedef struct VkPushConstantsInfo
 {
     VkStructureType sType;
@@ -17469,6 +17833,14 @@ typedef struct VkPushConstantsInfo
 } VkPushConstantsInfo;
 typedef VkPushConstantsInfo VkPushConstantsInfoKHR;
 
+typedef struct VkPushDataInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t offset;
+    VkHostAddressRangeConstEXT data;
+} VkPushDataInfoEXT;
+
 typedef struct VkPushDescriptorSetInfo
 {
     VkStructureType sType;
@@ -17919,6 +18291,14 @@ typedef struct VkResolveImageModeInfoKHR
     VkResolveModeFlagBits stencilResolveMode;
 } VkResolveImageModeInfoKHR;
 
+typedef struct VkResourceDescriptorInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDescriptorType type;
+    VkResourceDescriptorDataEXT data;
+} VkResourceDescriptorInfoEXT;
+
 typedef struct VkSamplerBlockMatchWindowCreateInfoQCOM
 {
     VkStructureType sType;
@@ -17942,28 +18322,6 @@ typedef struct VkSamplerCaptureDescriptorDataInfoEXT
     VkSampler WINE_VK_ALIGN(8) sampler;
 } VkSamplerCaptureDescriptorDataInfoEXT;
 
-typedef struct VkSamplerCreateInfo
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkSamplerCreateFlags flags;
-    VkFilter magFilter;
-    VkFilter minFilter;
-    VkSamplerMipmapMode mipmapMode;
-    VkSamplerAddressMode addressModeU;
-    VkSamplerAddressMode addressModeV;
-    VkSamplerAddressMode addressModeW;
-    float mipLodBias;
-    VkBool32 anisotropyEnable;
-    float maxAnisotropy;
-    VkBool32 compareEnable;
-    VkCompareOp compareOp;
-    float minLod;
-    float maxLod;
-    VkBorderColor borderColor;
-    VkBool32 unnormalizedCoordinates;
-} VkSamplerCreateInfo;
-
 typedef struct VkSamplerCubicWeightsCreateInfoQCOM
 {
     VkStructureType sType;
@@ -17979,6 +18337,13 @@ typedef struct VkSamplerCustomBorderColorCreateInfoEXT
     VkFormat format;
 } VkSamplerCustomBorderColorCreateInfoEXT;
 
+typedef struct VkSamplerCustomBorderColorIndexCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t index;
+} VkSamplerCustomBorderColorIndexCreateInfoEXT;
+
 typedef struct VkSamplerReductionModeCreateInfo
 {
     VkStructureType sType;
@@ -18121,6 +18486,14 @@ typedef struct VkShaderCreateInfoEXT
     const VkSpecializationInfo *pSpecializationInfo;
 } VkShaderCreateInfoEXT;
 
+typedef struct VkShaderDescriptorSetAndBindingMappingInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t mappingCount;
+    const VkDescriptorSetAndBindingMappingEXT *pMappings;
+} VkShaderDescriptorSetAndBindingMappingInfoEXT;
+
 typedef struct VkShaderModuleCreateInfo
 {
     VkStructureType sType;
@@ -18256,6 +18629,13 @@ typedef struct VkSubresourceLayout2
 typedef VkSubresourceLayout2 VkSubresourceLayout2KHR;
 typedef VkSubresourceLayout2 VkSubresourceLayout2EXT;
 
+typedef struct VkSubsampledImageFormatPropertiesEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t subsampledImageDescriptorCount;
+} VkSubsampledImageFormatPropertiesEXT;
+
 typedef struct VkSurfaceCapabilities2KHR
 {
     VkStructureType sType;
@@ -18430,15 +18810,6 @@ typedef struct VkTensorViewCaptureDescriptorDataInfoARM
     VkTensorViewARM WINE_VK_ALIGN(8) tensorView;
 } VkTensorViewCaptureDescriptorDataInfoARM;
 
-typedef struct VkTensorViewCreateInfoARM
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkTensorViewCreateFlagsARM WINE_VK_ALIGN(8) flags;
-    VkTensorARM WINE_VK_ALIGN(8) tensor;
-    VkFormat format;
-} VkTensorViewCreateInfoARM;
-
 typedef struct VkTextureLODGatherFormatPropertiesAMD
 {
     VkStructureType sType;
@@ -19407,6 +19778,8 @@ typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer2KHR)(VkCommandBuffer commandBu
 typedef void (VKAPI_PTR *PFN_vkCmdBindInvocationMaskHUAWEI)(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
 typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
 typedef void (VKAPI_PTR *PFN_vkCmdBindPipelineShaderGroupNV)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex);
+typedef void (VKAPI_PTR *PFN_vkCmdBindResourceHeapEXT)(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdBindSamplerHeapEXT)(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdBindShadersEXT)(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders);
 typedef void (VKAPI_PTR *PFN_vkCmdBindShadingRateImageNV)(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
 typedef void (VKAPI_PTR *PFN_vkCmdBindTileMemoryQCOM)(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo);
@@ -19521,6 +19894,7 @@ typedef void (VKAPI_PTR *PFN_vkCmdPreprocessGeneratedCommandsNV)(VkCommandBuffer
 typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues);
 typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2)(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2KHR)(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDataEXT)(VkCommandBuffer commandBuffer, const VkPushDataInfoEXT *pPushDataInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites);
 typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo);
@@ -19834,6 +20208,7 @@ typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSupportKHR)(VkDevice device
 typedef void (VKAPI_PTR *PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility);
 typedef void (VKAPI_PTR *PFN_vkGetDeviceBufferMemoryRequirements)(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 typedef void (VKAPI_PTR *PFN_vkGetDeviceBufferMemoryRequirementsKHR)(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+typedef uint64_t (VKAPI_PTR *PFN_vkGetDeviceCombinedImageSamplerIndexNVX)(VkDevice device, uint64_t imageViewIndex, uint64_t samplerIndex);
 typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceFaultInfoEXT)(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo);
 typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeatures)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures);
 typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures);
@@ -19867,6 +20242,7 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDev
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+typedef VkResult (VKAPI_PTR *PFN_vkGetImageOpaqueCaptureDataEXT)(VkDevice device, uint32_t imageCount, const VkImage *pImages, VkHostAddressRangeEXT *pDatas);
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements);
 typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements);
@@ -19897,6 +20273,7 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDim
 typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties);
 typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties);
 typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV)(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties);
+typedef VkDeviceSize (VKAPI_PTR *PFN_vkGetPhysicalDeviceDescriptorSizeEXT)(VkPhysicalDevice physicalDevice, VkDescriptorType descriptorType);
 typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFenceProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
@@ -19979,6 +20356,7 @@ typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleIdentifierEXT)(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages);
 typedef void (VKAPI_PTR *PFN_vkGetTensorMemoryRequirementsARM)(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+typedef VkResult (VKAPI_PTR *PFN_vkGetTensorOpaqueCaptureDataARM)(VkDevice device, uint32_t tensorCount, const VkTensorARM *pTensors, VkHostAddressRangeEXT *pDatas);
 typedef VkResult (VKAPI_PTR *PFN_vkGetTensorOpaqueCaptureDescriptorDataARM)(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData);
 typedef VkResult (VKAPI_PTR *PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM)(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
@@ -20006,6 +20384,7 @@ typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCo
 typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
 typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2KHR)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
 typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
+typedef VkResult (VKAPI_PTR *PFN_vkRegisterCustomBorderColorEXT)(VkDevice device, const VkSamplerCustomBorderColorCreateInfoEXT *pBorderColor, VkBool32 requestIndex, uint32_t *pIndex);
 typedef VkResult (VKAPI_PTR *PFN_vkReleaseCapturedPipelineDataKHR)(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator);
 typedef VkResult (VKAPI_PTR *PFN_vkReleasePerformanceConfigurationINTEL)(VkDevice device, VkPerformanceConfigurationINTEL configuration);
 typedef void (VKAPI_PTR *PFN_vkReleaseProfilingLockKHR)(VkDevice device);
@@ -20038,6 +20417,7 @@ typedef void (VKAPI_PTR *PFN_vkUninitializePerformanceApiINTEL)(VkDevice device)
 typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
 typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2)(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
 typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2KHR)(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
+typedef void (VKAPI_PTR *PFN_vkUnregisterCustomBorderColorEXT)(VkDevice device, uint32_t index);
 typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSetWithTemplate)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData);
 typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSetWithTemplateKHR)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData);
 typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies);
@@ -20051,6 +20431,8 @@ typedef VkResult (VKAPI_PTR *PFN_vkWaitSemaphores)(VkDevice device, const VkSema
 typedef VkResult (VKAPI_PTR *PFN_vkWaitSemaphoresKHR)(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout);
 typedef VkResult (VKAPI_PTR *PFN_vkWriteAccelerationStructuresPropertiesKHR)(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
 typedef VkResult (VKAPI_PTR *PFN_vkWriteMicromapsPropertiesEXT)(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
+typedef VkResult (VKAPI_PTR *PFN_vkWriteResourceDescriptorsEXT)(VkDevice device, uint32_t resourceCount, const VkResourceDescriptorInfoEXT *pResources, const VkHostAddressRangeEXT *pDescriptors);
+typedef VkResult (VKAPI_PTR *PFN_vkWriteSamplerDescriptorsEXT)(VkDevice device, uint32_t samplerCount, const VkSamplerCreateInfo *pSamplers, const VkHostAddressRangeEXT *pDescriptors);
 
 #ifndef VK_NO_PROTOTYPES
 VkResult VKAPI_CALL vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex);
@@ -20100,6 +20482,8 @@ void VKAPI_CALL vkCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer
 void VKAPI_CALL vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
 void VKAPI_CALL vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
 void VKAPI_CALL vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex);
+void VKAPI_CALL vkCmdBindResourceHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo);
+void VKAPI_CALL vkCmdBindSamplerHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT *pBindInfo);
 void VKAPI_CALL vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders);
 void VKAPI_CALL vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
 void VKAPI_CALL vkCmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo);
@@ -20214,6 +20598,7 @@ void VKAPI_CALL vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer
 void VKAPI_CALL vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues);
 void VKAPI_CALL vkCmdPushConstants2(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo);
 void VKAPI_CALL vkCmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo);
+void VKAPI_CALL vkCmdPushDataEXT(VkCommandBuffer commandBuffer, const VkPushDataInfoEXT *pPushDataInfo);
 void VKAPI_CALL vkCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites);
 void VKAPI_CALL vkCmdPushDescriptorSet2(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo);
 void VKAPI_CALL vkCmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo);
@@ -20527,6 +20912,7 @@ void VKAPI_CALL vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDesc
 void VKAPI_CALL vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility);
 void VKAPI_CALL vkGetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+uint64_t VKAPI_CALL vkGetDeviceCombinedImageSamplerIndexNVX(VkDevice device, uint64_t imageViewIndex, uint64_t samplerIndex);
 VkResult VKAPI_CALL vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo);
 void VKAPI_CALL vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures);
 void VKAPI_CALL vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures);
@@ -20560,6 +20946,7 @@ VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, Vk
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+VkResult VKAPI_CALL vkGetImageOpaqueCaptureDataEXT(VkDevice device, uint32_t imageCount, const VkImage *pImages, VkHostAddressRangeEXT *pDatas);
 VkResult VKAPI_CALL vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 void VKAPI_CALL vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements);
 void VKAPI_CALL vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements);
@@ -20590,6 +20977,7 @@ VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsProper
 VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties);
 VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties);
 VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties);
+VkDeviceSize VKAPI_CALL vkGetPhysicalDeviceDescriptorSizeEXT(VkPhysicalDevice physicalDevice, VkDescriptorType descriptorType);
 void VKAPI_CALL vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 void VKAPI_CALL vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 void VKAPI_CALL vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
@@ -20672,6 +21060,7 @@ void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const
 void VKAPI_CALL vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier);
 VkResult VKAPI_CALL vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages);
 void VKAPI_CALL vkGetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+VkResult VKAPI_CALL vkGetTensorOpaqueCaptureDataARM(VkDevice device, uint32_t tensorCount, const VkTensorARM *pTensors, VkHostAddressRangeEXT *pDatas);
 VkResult VKAPI_CALL vkGetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
@@ -20699,6 +21088,7 @@ VkResult VKAPI_CALL vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkS
 VkResult VKAPI_CALL vkQueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
 VkResult VKAPI_CALL vkQueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
 VkResult VKAPI_CALL vkQueueWaitIdle(VkQueue queue);
+VkResult VKAPI_CALL vkRegisterCustomBorderColorEXT(VkDevice device, const VkSamplerCustomBorderColorCreateInfoEXT *pBorderColor, VkBool32 requestIndex, uint32_t *pIndex);
 VkResult VKAPI_CALL vkReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator);
 VkResult VKAPI_CALL vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration);
 void VKAPI_CALL vkReleaseProfilingLockKHR(VkDevice device);
@@ -20731,6 +21121,7 @@ void VKAPI_CALL vkUninitializePerformanceApiINTEL(VkDevice device);
 void VKAPI_CALL vkUnmapMemory(VkDevice device, VkDeviceMemory memory);
 VkResult VKAPI_CALL vkUnmapMemory2(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
 VkResult VKAPI_CALL vkUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
+void VKAPI_CALL vkUnregisterCustomBorderColorEXT(VkDevice device, uint32_t index);
 void VKAPI_CALL vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData);
 void VKAPI_CALL vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData);
 void VKAPI_CALL vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies);
@@ -20744,6 +21135,8 @@ VkResult VKAPI_CALL vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo
 VkResult VKAPI_CALL vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout);
 VkResult VKAPI_CALL vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
 VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
+VkResult VKAPI_CALL vkWriteResourceDescriptorsEXT(VkDevice device, uint32_t resourceCount, const VkResourceDescriptorInfoEXT *pResources, const VkHostAddressRangeEXT *pDescriptors);
+VkResult VKAPI_CALL vkWriteSamplerDescriptorsEXT(VkDevice device, uint32_t samplerCount, const VkSamplerCreateInfo *pSamplers, const VkHostAddressRangeEXT *pDescriptors);
 #endif /* VK_NO_PROTOTYPES */
 
 #define ALL_VK_DEVICE_FUNCS \
@@ -20794,6 +21187,8 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkCmdBindInvocationMaskHUAWEI) \
     USE_VK_FUNC(vkCmdBindPipeline) \
     USE_VK_FUNC(vkCmdBindPipelineShaderGroupNV) \
+    USE_VK_FUNC(vkCmdBindResourceHeapEXT) \
+    USE_VK_FUNC(vkCmdBindSamplerHeapEXT) \
     USE_VK_FUNC(vkCmdBindShadersEXT) \
     USE_VK_FUNC(vkCmdBindShadingRateImageNV) \
     USE_VK_FUNC(vkCmdBindTileMemoryQCOM) \
@@ -20908,6 +21303,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkCmdPushConstants) \
     USE_VK_FUNC(vkCmdPushConstants2) \
     USE_VK_FUNC(vkCmdPushConstants2KHR) \
+    USE_VK_FUNC(vkCmdPushDataEXT) \
     USE_VK_FUNC(vkCmdPushDescriptorSet) \
     USE_VK_FUNC(vkCmdPushDescriptorSet2) \
     USE_VK_FUNC(vkCmdPushDescriptorSet2KHR) \
@@ -21196,6 +21592,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetDeviceAccelerationStructureCompatibilityKHR) \
     USE_VK_FUNC(vkGetDeviceBufferMemoryRequirements) \
     USE_VK_FUNC(vkGetDeviceBufferMemoryRequirementsKHR) \
+    USE_VK_FUNC(vkGetDeviceCombinedImageSamplerIndexNVX) \
     USE_VK_FUNC(vkGetDeviceFaultInfoEXT) \
     USE_VK_FUNC(vkGetDeviceGroupPeerMemoryFeatures) \
     USE_VK_FUNC(vkGetDeviceGroupPeerMemoryFeaturesKHR) \
@@ -21228,6 +21625,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetImageMemoryRequirements) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2KHR) \
+    USE_VK_FUNC(vkGetImageOpaqueCaptureDataEXT) \
     USE_VK_FUNC(vkGetImageOpaqueCaptureDescriptorDataEXT) \
     USE_VK_FUNC(vkGetImageSparseMemoryRequirements) \
     USE_VK_FUNC(vkGetImageSparseMemoryRequirements2) \
@@ -21283,6 +21681,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetShaderModuleIdentifierEXT) \
     USE_VK_FUNC(vkGetSwapchainImagesKHR) \
     USE_VK_FUNC(vkGetTensorMemoryRequirementsARM) \
+    USE_VK_FUNC(vkGetTensorOpaqueCaptureDataARM) \
     USE_VK_FUNC(vkGetTensorOpaqueCaptureDescriptorDataARM) \
     USE_VK_FUNC(vkGetTensorViewOpaqueCaptureDescriptorDataARM) \
     USE_VK_FUNC(vkGetValidationCacheDataEXT) \
@@ -21310,6 +21709,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkQueueSubmit2) \
     USE_VK_FUNC(vkQueueSubmit2KHR) \
     USE_VK_FUNC(vkQueueWaitIdle) \
+    USE_VK_FUNC(vkRegisterCustomBorderColorEXT) \
     USE_VK_FUNC(vkReleaseCapturedPipelineDataKHR) \
     USE_VK_FUNC(vkReleasePerformanceConfigurationINTEL) \
     USE_VK_FUNC(vkReleaseProfilingLockKHR) \
@@ -21341,6 +21741,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkUnmapMemory) \
     USE_VK_FUNC(vkUnmapMemory2) \
     USE_VK_FUNC(vkUnmapMemory2KHR) \
+    USE_VK_FUNC(vkUnregisterCustomBorderColorEXT) \
     USE_VK_FUNC(vkUpdateDescriptorSetWithTemplate) \
     USE_VK_FUNC(vkUpdateDescriptorSetWithTemplateKHR) \
     USE_VK_FUNC(vkUpdateDescriptorSets) \
@@ -21353,7 +21754,9 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkWaitSemaphores) \
     USE_VK_FUNC(vkWaitSemaphoresKHR) \
     USE_VK_FUNC(vkWriteAccelerationStructuresPropertiesKHR) \
-    USE_VK_FUNC(vkWriteMicromapsPropertiesEXT)
+    USE_VK_FUNC(vkWriteMicromapsPropertiesEXT) \
+    USE_VK_FUNC(vkWriteResourceDescriptorsEXT) \
+    USE_VK_FUNC(vkWriteSamplerDescriptorsEXT)
 
 #define ALL_VK_CLIENT_DEVICE_EXTS \
     USE_VK_EXT(VK_AMD_anti_lag) \
@@ -21409,6 +21812,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_EXT(VK_EXT_depth_clip_enable) \
     USE_VK_EXT(VK_EXT_depth_range_unrestricted) \
     USE_VK_EXT(VK_EXT_descriptor_buffer) \
+    USE_VK_EXT(VK_EXT_descriptor_heap) \
     USE_VK_EXT(VK_EXT_descriptor_indexing) \
     USE_VK_EXT(VK_EXT_device_address_binding_report) \
     USE_VK_EXT(VK_EXT_device_fault) \
@@ -21489,6 +21893,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_EXT(VK_EXT_shader_replicated_composites) \
     USE_VK_EXT(VK_EXT_shader_stencil_export) \
     USE_VK_EXT(VK_EXT_shader_subgroup_ballot) \
+    USE_VK_EXT(VK_EXT_shader_subgroup_partitioned) \
     USE_VK_EXT(VK_EXT_shader_subgroup_vote) \
     USE_VK_EXT(VK_EXT_shader_tile_image) \
     USE_VK_EXT(VK_EXT_shader_uniform_buffer_unsized_array) \
@@ -21556,6 +21961,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_EXT(VK_KHR_imageless_framebuffer) \
     USE_VK_EXT(VK_KHR_incremental_present) \
     USE_VK_EXT(VK_KHR_index_type_uint8) \
+    USE_VK_EXT(VK_KHR_internally_synchronized_queues) \
     USE_VK_EXT(VK_KHR_line_rasterization) \
     USE_VK_EXT(VK_KHR_load_store_op_none) \
     USE_VK_EXT(VK_KHR_maintenance1) \
@@ -21674,6 +22080,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_EXT(VK_NV_partitioned_acceleration_structure) \
     USE_VK_EXT(VK_NV_per_stage_descriptor_set) \
     USE_VK_EXT(VK_NV_present_barrier) \
+    USE_VK_EXT(VK_NV_push_constant_bank) \
     USE_VK_EXT(VK_NV_raw_access_chains) \
     USE_VK_EXT(VK_NV_ray_tracing) \
     USE_VK_EXT(VK_NV_ray_tracing_invocation_reorder) \
@@ -21749,6 +22156,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV) \
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeVectorPropertiesNV) \
+    USE_VK_FUNC(vkGetPhysicalDeviceDescriptorSizeEXT) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferProperties) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferPropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalFenceProperties) \
-- 
GitLab

