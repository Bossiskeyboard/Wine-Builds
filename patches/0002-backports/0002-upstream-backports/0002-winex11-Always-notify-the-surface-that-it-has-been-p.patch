From 4bf62934b8c65f266c8862ded7d7a8f04f309f25 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 16 Sep 2025 09:39:04 +0200
Subject: [PATCH 02/17] winex11: Always notify the surface that it has been
 presented.

It might not be offscreen but it might have been detached if multiple
client surfaces are involved.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=58602
---
 dlls/winex11.drv/init.c   |  5 +++++
 dlls/winex11.drv/opengl.c | 17 +++++++----------
 2 files changed, 12 insertions(+), 10 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 696083b8fab..c9854c1dbda 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -320,6 +320,8 @@ static void client_surface_update_offscreen( HWND hwnd, struct x11drv_client_sur
     BOOL offscreen = needs_offscreen_rendering( hwnd );
     struct x11drv_win_data *data;
 
+    TRACE( "%s offscreen %u\n", debugstr_client_surface( &surface->client ), offscreen );
+
     if (InterlockedExchange( &surface->client.offscreen, offscreen ) == offscreen)
     {
         if (!offscreen && (data = get_win_data( hwnd )))
@@ -386,6 +388,8 @@ static void X11DRV_client_surface_present( struct client_surface *client, HDC hd
     Drawable window;
     HRGN region;
 
+    TRACE( "%s\n", debugstr_client_surface( client ) );
+
     client_surface_update_size( hwnd, surface );
     client_surface_update_offscreen( hwnd, surface );
 
@@ -433,6 +437,7 @@ Window x11drv_client_surface_create( HWND hwnd, const XVisualInfo *visual, Color
     }
     NtUserGetClientRect( hwnd, &surface->rect, NtUserGetDpiForWindow( hwnd ) );
 
+    TRACE( "Created %s for client window %lx\n", debugstr_client_surface( &surface->client ), surface->window );
     *client = &surface->client;
     return surface->window;
 }
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index a25f291a2cf..b810689ff3d 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1188,8 +1188,9 @@ static void x11drv_surface_flush( struct opengl_drawable *base, UINT flags )
     {
         if (!(flags & GL_FLUSH_FINISHED)) funcs->p_glFinish();
         XFlush( gdi_display );
-        client_surface_present( base->client );
     }
+
+    client_surface_present( base->client );
 }
 
 /***********************************************************************
@@ -1453,12 +1454,9 @@ static BOOL x11drv_surface_swap( struct opengl_drawable *base )
         if (pglXWaitForSbcOML) pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
     }
 
-    if (offscreen)
-    {
-        if (!pglXWaitForSbcOML) XFlush( gdi_display );
-        client_surface_present( base->client );
-    }
+    if (offscreen && !pglXWaitForSbcOML) XFlush( gdi_display );
 
+    client_surface_present( base->client );
     return TRUE;
 }
 
@@ -1477,8 +1475,9 @@ static void x11drv_egl_surface_flush( struct opengl_drawable *base, UINT flags )
     {
         if (!(flags & GL_FLUSH_FINISHED)) funcs->p_glFinish();
         XFlush( gdi_display );
-        client_surface_present( base->client );
     }
+
+    client_surface_present( base->client );
 }
 
 static BOOL x11drv_egl_surface_swap( struct opengl_drawable *base )
@@ -1490,11 +1489,9 @@ static BOOL x11drv_egl_surface_swap( struct opengl_drawable *base )
     funcs->p_eglSwapBuffers( egl->display, gl->base.surface );
 
     if (InterlockedCompareExchange( &base->client->offscreen, 0, 0 ))
-    {
         XFlush( gdi_display );
-        client_surface_present( base->client );
-    }
 
+    client_surface_present( base->client );
     return TRUE;
 }
 
-- 
2.51.2

