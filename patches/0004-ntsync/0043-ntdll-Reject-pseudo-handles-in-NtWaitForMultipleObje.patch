From c9d5e0ba7b400574254a3264041a19707f9812e6 Mon Sep 17 00:00:00 2001
From: Marc-Aurel Zent <mzent@codeweavers.com>
Date: Thu, 30 Oct 2025 22:12:40 +0100
Subject: [PATCH 43/44] ntdll: Reject pseudo-handles in
 NtWaitForMultipleObjects.

---
 dlls/kernel32/tests/sync.c     | 16 +++++++--------
 dlls/kernel32/tests/sync.c.rej | 37 ++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/sync.c         |  6 ++++++
 dlls/ntdll/unix/sync.c.rej     | 15 ++++++++++++++
 4 files changed, 66 insertions(+), 8 deletions(-)
 create mode 100644 dlls/kernel32/tests/sync.c.rej
 create mode 100644 dlls/ntdll/unix/sync.c.rej

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index aea8522ce22..f9d2d4bbcd3 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -1725,26 +1725,26 @@ static void test_WaitForMultipleObjects(void)
     maxevents[0] = GetCurrentProcess();
     SetLastError(0xdeadbeef);
     r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
-    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
-    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
-                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+    ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+    ok(GetLastError() == ERROR_INVALID_HANDLE,
+       "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
 
     maxevents[0] = GetCurrentThread();
     SetLastError(0xdeadbeef);
     r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
-    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
-    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
-                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+    ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+    ok(GetLastError() == ERROR_INVALID_HANDLE,
+       "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
 
     timeout.QuadPart = -1000000;
     maxevents[0] = GetCurrentProcess();
     status = pNtWaitForMultipleObjects(1, maxevents, TRUE, FALSE, &timeout);
-    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+    ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
 
     timeout.QuadPart = -1000000;
     maxevents[0] = GetCurrentThread();
     status = pNtWaitForMultipleObjects(1, maxevents, TRUE, FALSE, &timeout);
-    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+    ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
 }
 
 static BOOL g_initcallback_ret, g_initcallback_called;
diff --git a/dlls/kernel32/tests/sync.c.rej b/dlls/kernel32/tests/sync.c.rej
new file mode 100644
index 00000000000..7355ade28bd
--- /dev/null
+++ b/dlls/kernel32/tests/sync.c.rej
@@ -0,0 +1,37 @@
+--- dlls/kernel32/tests/sync.c
++++ dlls/kernel32/tests/sync.c
+@@ -1432,26 +1432,26 @@ static void test_WaitForMultipleObjects(void)
+     maxevents[0] = GetCurrentProcess();
+     SetLastError(0xdeadbeef);
+     r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
+-    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+-    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
+-                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
++    ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
++    ok(GetLastError() == ERROR_INVALID_HANDLE,
++       "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+ 
+     maxevents[0] = GetCurrentThread();
+     SetLastError(0xdeadbeef);
+     r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
+-    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+-    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
+-                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
++    ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
++    ok(GetLastError() == ERROR_INVALID_HANDLE,
++       "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+ 
+     timeout.QuadPart = -1000000;
+     maxevents[0] = GetCurrentProcess();
+     status = pNtWaitForMultipleObjects(1, maxevents, WaitAny, FALSE, &timeout);
+-    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
++    ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+ 
+     timeout.QuadPart = -1000000;
+     maxevents[0] = GetCurrentThread();
+     status = pNtWaitForMultipleObjects(1, maxevents, WaitAny, FALSE, &timeout);
+-    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
++    ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+ }
+ 
+ static BOOL g_initcallback_ret, g_initcallback_called;
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 6a587d58fc2..5c116fe7b56 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2707,6 +2707,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
     }
 
+    /* Reject pseudo-handles up front. These are not valid for multi-object waits. */
+    for (i = 0; i < count; i++)
+    {
+        if (is_pseudo_handle( handles[i] )) return STATUS_INVALID_HANDLE;
+    }
+
     if ((ret = inproc_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
     {
         TRACE( "-> %#x\n", ret );
diff --git a/dlls/ntdll/unix/sync.c.rej b/dlls/ntdll/unix/sync.c.rej
new file mode 100644
index 00000000000..98dce15db68
--- /dev/null
+++ b/dlls/ntdll/unix/sync.c.rej
@@ -0,0 +1,15 @@
+--- dlls/ntdll/unix/sync.c
++++ dlls/ntdll/unix/sync.c
+@@ -2319,6 +2319,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, WA
+         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+     }
+ 
++    /* Reject pseudo-handles up front. These are not valid for multi-object waits. */
++    for (i = 0; i < count; i++)
++    {
++        if (is_pseudo_handle( handles[i] )) return STATUS_INVALID_HANDLE;
++    }
++
+     if ((ret = inproc_wait( count, handles, type, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+     {
+         TRACE( "-> %#x\n", ret );
-- 
2.51.2

